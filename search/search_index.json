{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FSEG - Fast Sun-Earth Geometry A library on sun position and sunlight analysis from the observer's viewpoint, which comsists of a simplistic python frontend and an extensible C++ backend. Get Started Features & Algorithms Topocentric Sun Position: SPA 1 SG2 Supported Platforms MacOSX-10.9-x86_64 Ubuntu-20.04-manylinux_x86_64 Windows-2019-win_amd64 Reda, I.; Andreas, A. (2003). Solar Position Algorithm for Solar Radiation Applications. 55 pp.; NREL Report No. TP-560-34302, Revised January 2008. \u21a9","title":"Home"},{"location":"#fseg-fast-sun-earth-geometry","text":"A library on sun position and sunlight analysis from the observer's viewpoint, which comsists of a simplistic python frontend and an extensible C++ backend. Get Started","title":"FSEG - Fast Sun-Earth Geometry"},{"location":"#features-algorithms","text":"Topocentric Sun Position: SPA 1 SG2","title":"Features &amp; Algorithms"},{"location":"#supported-platforms","text":"MacOSX-10.9-x86_64 Ubuntu-20.04-manylinux_x86_64 Windows-2019-win_amd64 Reda, I.; Andreas, A. (2003). Solar Position Algorithm for Solar Radiation Applications. 55 pp.; NREL Report No. TP-560-34302, Revised January 2008. \u21a9","title":"Supported Platforms"},{"location":"about/contributing/","text":"Contributing to FSEG \u4f17\u4eba\u62fe\u67f4\u706b\u7130\u9ad8 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Contributions are made to this repo via Issues and Pull Requests (PRs). For those unfamiliar, please visit the \"fork-and-pull\" Git workflow for reference. Reading and following these guidelines will help us make the contribution process easy and effective for everyone involved. Code of Conduct This project and everyone participating in it is governed by the FSEG Code of Conduct . By participating, you are expected to uphold this code. Please report unacceptable behavior to gnosoir@hotmail.com . Issues Issues should be used to report problems with the library, request a new feature, or to discuss potential changes before a PR is created. When you create a new Issue, a template will be loaded that will guide you through collecting and providing the information we need to investigate. If you find an Issue that addresses the problem you're having, please add your own reproduction information to the existing issue rather than creating a new one. Adding a reaction can also help be indicating to our maintainers that a particular problem is affecting more than just the reporter. Pull Requests PRs to our libraries are always welcome and can be a quick way to get your fix or improvement slated for the next release. In general, PRs should: Only fix the bug OR add the functionality in question, not both. Add unit or integration tests for fixed or changed functionality (if a test suite already exists). Address a single concern in the least number of changed lines as possible. Include documentation in the repo, whether as part of the official docs, in docstrings. Be accompanied by a complete Pull Request template (loaded automatically when a PR is created). For changes that address core functionality or would require breaking changes (e.g. a major release), it's best to open an Issue to discuss your proposal first. This is not required but can save time creating and reviewing changes. In general, we follow the \"fork-and-pull\" Git workflow Fork the repository to your own Github account Clone the project to your machine Create a branch locally with a succinct but descriptive name Commit changes to the branch Following any formatting and testing guidelines specific to this repo Push changes to your fork Open a PR in our repository and follow the PR template so that we can efficiently review the changes.","title":"Contributing"},{"location":"about/contributing/#contributing-to-fseg","text":"\u4f17\u4eba\u62fe\u67f4\u706b\u7130\u9ad8 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Contributions are made to this repo via Issues and Pull Requests (PRs). For those unfamiliar, please visit the \"fork-and-pull\" Git workflow for reference. Reading and following these guidelines will help us make the contribution process easy and effective for everyone involved.","title":"Contributing to FSEG"},{"location":"about/contributing/#code-of-conduct","text":"This project and everyone participating in it is governed by the FSEG Code of Conduct . By participating, you are expected to uphold this code. Please report unacceptable behavior to gnosoir@hotmail.com .","title":"Code of Conduct"},{"location":"about/contributing/#issues","text":"Issues should be used to report problems with the library, request a new feature, or to discuss potential changes before a PR is created. When you create a new Issue, a template will be loaded that will guide you through collecting and providing the information we need to investigate. If you find an Issue that addresses the problem you're having, please add your own reproduction information to the existing issue rather than creating a new one. Adding a reaction can also help be indicating to our maintainers that a particular problem is affecting more than just the reporter.","title":"Issues"},{"location":"about/contributing/#pull-requests","text":"PRs to our libraries are always welcome and can be a quick way to get your fix or improvement slated for the next release. In general, PRs should: Only fix the bug OR add the functionality in question, not both. Add unit or integration tests for fixed or changed functionality (if a test suite already exists). Address a single concern in the least number of changed lines as possible. Include documentation in the repo, whether as part of the official docs, in docstrings. Be accompanied by a complete Pull Request template (loaded automatically when a PR is created). For changes that address core functionality or would require breaking changes (e.g. a major release), it's best to open an Issue to discuss your proposal first. This is not required but can save time creating and reviewing changes. In general, we follow the \"fork-and-pull\" Git workflow Fork the repository to your own Github account Clone the project to your machine Create a branch locally with a succinct but descriptive name Commit changes to the branch Following any formatting and testing guidelines specific to this repo Push changes to your fork Open a PR in our repository and follow the PR template so that we can efficiently review the changes.","title":"Pull Requests"},{"location":"about/history/","text":"Release Notes v0.7.6 (2022-06-28) Bug Fixes 30e2f2e fix that collect_news changed last head commit Documentation Improvements PR#22 Update Documents: user-guide/install.md dev-guide/ Maintenance PR#22 Use mermaid-js to draw UML graphs v0.7.5 (2022-06-27) Features PR#20 Adopt Tox for local pytest & mkdocs #18 Add towncrier news collection Documentation Improvements PR#23 Supplement change logs from v0.5.0 to v0.7.5 Maintenance PR#23 Add workflow to build changelog and docs, then publish to GH Pages v0.7.4 (2022-06-21) Bug Fixes PR#14 tweak tag in build_sdist and build_wheel by CIBW Maintenance PR#17 directory refactoring v0.7.2.1 (2022-06-21) Bug Fixes - 0b1abcc call reused workflow publish_pypi.yml with inherited secrets Development Milestone PR#12 support Linux on Ubuntu20.04 and MSVC on windows2019 Maintenance - 6812935 GH checkout with ref and full history PR#15 release triggered ci & publish v0.6.0 (2022-06-18) Maintenance PR#6 customize github action workflows for CI v0.5.0 (2022-05-25) Development Milestone #1 #2 #3 A SunEarthAnalyzer API wrapping pybind11 C++ extension and CI/CD facilities SPA sun position algorithm implemented; Pytest empowered tests; pre-commit hooks, including mypy,isort,black,flake docs ready to gh-deploy by mkdocs, with the material theme empowered by @towncrier","title":"History"},{"location":"about/history/#release-notes","text":"","title":"Release Notes"},{"location":"about/history/#v076-2022-06-28","text":"","title":"v0.7.6 (2022-06-28)"},{"location":"about/history/#bug-fixes","text":"30e2f2e fix that collect_news changed last head commit","title":"Bug Fixes"},{"location":"about/history/#documentation-improvements","text":"PR#22 Update Documents: user-guide/install.md dev-guide/","title":"Documentation Improvements"},{"location":"about/history/#maintenance","text":"PR#22 Use mermaid-js to draw UML graphs","title":"Maintenance"},{"location":"about/history/#v075-2022-06-27","text":"","title":"v0.7.5 (2022-06-27)"},{"location":"about/history/#features","text":"PR#20 Adopt Tox for local pytest & mkdocs #18 Add towncrier news collection","title":"Features"},{"location":"about/history/#documentation-improvements_1","text":"PR#23 Supplement change logs from v0.5.0 to v0.7.5","title":"Documentation Improvements"},{"location":"about/history/#maintenance_1","text":"PR#23 Add workflow to build changelog and docs, then publish to GH Pages","title":"Maintenance"},{"location":"about/history/#v074-2022-06-21","text":"","title":"v0.7.4 (2022-06-21)"},{"location":"about/history/#bug-fixes_1","text":"PR#14 tweak tag in build_sdist and build_wheel by CIBW","title":"Bug Fixes"},{"location":"about/history/#maintenance_2","text":"PR#17 directory refactoring","title":"Maintenance"},{"location":"about/history/#v0721-2022-06-21","text":"","title":"v0.7.2.1 (2022-06-21)"},{"location":"about/history/#bug-fixes_2","text":"- 0b1abcc call reused workflow publish_pypi.yml with inherited secrets","title":"Bug Fixes"},{"location":"about/history/#development-milestone","text":"PR#12 support Linux on Ubuntu20.04 and MSVC on windows2019","title":"Development Milestone"},{"location":"about/history/#maintenance_3","text":"- 6812935 GH checkout with ref and full history PR#15 release triggered ci & publish","title":"Maintenance"},{"location":"about/history/#v060-2022-06-18","text":"","title":"v0.6.0 (2022-06-18)"},{"location":"about/history/#maintenance_4","text":"PR#6 customize github action workflows for CI","title":"Maintenance"},{"location":"about/history/#v050-2022-05-25","text":"","title":"v0.5.0 (2022-05-25)"},{"location":"about/history/#development-milestone_1","text":"#1 #2 #3 A SunEarthAnalyzer API wrapping pybind11 C++ extension and CI/CD facilities SPA sun position algorithm implemented; Pytest empowered tests; pre-commit hooks, including mypy,isort,black,flake docs ready to gh-deploy by mkdocs, with the material theme empowered by @towncrier","title":"Development Milestone"},{"location":"about/license/","text":"License FSEG adopts LGPLv2.1 to boost knowledge sharing between both industrial experts and IT developers. \u672c\u9879\u76ee\u7248\u6743\u91c7\u7528 LGPLv2.1 \u5f00\u6e90\u534f\u8bae\u4ee5\u4fc3\u8fdb\u76f8\u5173\u884c\u4e1a\u77e5\u8bc6\u548cIT\u4f18\u5316\u65b9\u6cd5\u7684\u5171\u4eab; \u5bf9\u4e8e\u5546\u4e1a\u516c\u53f8\uff0c\u8fd9\u610f\u5473\u7740\u57fa\u4e8e\u672c\u9879\u76ee\u7684\u5e93\u6587\u4ef6\u53ef\u4ee5\u8fdb\u884c\u4efb\u610f\u5f00\u6e90\u6216\u8005\u95ed\u6e90\u8f6f\u4ef6\u7684\u5f00\u53d1\uff0c\u4f46\u662f\u5bf9\u672c\u9879\u76ee\u7684 \u4efb\u610f\u4fee\u6539 \u9700\u8981\u91c7\u7528\u540c\u6837\u7684\u534f\u8bae\u5f00\u6e90\u3002","title":"License"},{"location":"about/license/#license","text":"FSEG adopts LGPLv2.1 to boost knowledge sharing between both industrial experts and IT developers. \u672c\u9879\u76ee\u7248\u6743\u91c7\u7528 LGPLv2.1 \u5f00\u6e90\u534f\u8bae\u4ee5\u4fc3\u8fdb\u76f8\u5173\u884c\u4e1a\u77e5\u8bc6\u548cIT\u4f18\u5316\u65b9\u6cd5\u7684\u5171\u4eab; \u5bf9\u4e8e\u5546\u4e1a\u516c\u53f8\uff0c\u8fd9\u610f\u5473\u7740\u57fa\u4e8e\u672c\u9879\u76ee\u7684\u5e93\u6587\u4ef6\u53ef\u4ee5\u8fdb\u884c\u4efb\u610f\u5f00\u6e90\u6216\u8005\u95ed\u6e90\u8f6f\u4ef6\u7684\u5f00\u53d1\uff0c\u4f46\u662f\u5bf9\u672c\u9879\u76ee\u7684 \u4efb\u610f\u4fee\u6539 \u9700\u8981\u91c7\u7528\u540c\u6837\u7684\u534f\u8bae\u5f00\u6e90\u3002","title":"License"},{"location":"about/motive/","text":"When tring to build an autonomous site planning model, I was shocked by the backwardness of sunlight analysis technology in the Chinese real estate design industry: all available products are distributed as close-sourced \"plugins\" [\u7528\u8fc7\u7684\u90fd\u77e5\u9053~] in commercial desktop softwares, such as AutoCAD and Rhino Grasshopper . Worse yet, many are slow and not upgraded for years. no python package available makes it impossible to utilize DNN models, which nowadays are usually implemented on either tensorflow or pytorch , and nothing else . The problem of sun position involves not only solar astronomy about space-time transformation between celestial and topocentric coordinates, but also convention in specific industries. It needs great effort for a single person to comprehend related knowledge scattered in various papers and documents. Thus FSEG is initiated as: a container of algorithms and know-how on sun position in different industries an easy-to-use API to relieve users from underlying astronomical and computational complexities","title":"Motivation"},{"location":"dev-guide/dev-guide/","text":"Developer's Guide Local Development Procedure Install Anaconda on System Install CMake on System Install C++/C Compiler on System, w.r.t. supported platforms Checkout issue related branch from Github Prepare Python environment, either by pip install -r requirements-dev.txt or pip install tox && tox -e dev Browse and edit source code as your wish, VSCode recommened as the IDE Broadcast your work using towncrier by: towncrier create {source}.{type} --edit where {type} is one of: feature: for new features api: for API changes bug: for bug fixes maint: for maintenance and ci related dev: for breakthrough changes/milestone docs: for documentation changes author: for contributor names and where the {source} part of the filename is: 42 when the change is described in issue 42 PR42 when the change has been implemented in pull request 42, and there is no associated issue Cabcdef when the change has been implemented in changeset abcdef, and there is no associated issue or pull request. username for contributors (author extention). It should be the username part of their commits\u2019 email address. Library Design 1. Flowchart flowchart LR i1((Observatory)) i2((OBS_TIME_T)) a1[SunEarthAnalyzer] a2[interface of<br>SPA_Analyzer] b1[SPA_Analyzer] b2[(C implementation of<br>SPA algorithm)] i1---a1 i2---a1 Python<===>|pybind11|CPP subgraph Python a1-->|set_observatory|a2 a1-->|sun_position_at|a2 end subgraph CPP direction TB b1-->|calculate_sun_position_at|b2 end 2. Sequence Diagram sequenceDiagram participant SunEarthAnalyzer participant SPA_Analyzer participant SPA SunEarthAnalyzer ->>+ SPA_Analyzer: load algorithm SPA_Analyzer -->>- SunEarthAnalyzer: calculator SunEarthAnalyzer ->> SPA_Analyzer: set observatory SunEarthAnalyzer ->>+ SPA_Analyzer: sun position at ? % break when observatory not set % SPA_Analyzer -->> SunEarthAnalyzer: RuntimeError % end SPA_Analyzer -->>+ SPA: calculate sun position at ? % break when validate_inputs fails % SPA-->SPA_Analyzer: error code % end SPA -->> SPA: spa calcluate SPA -->>- SPA_Analyzer: spa_data SPA_Analyzer -->>- SunEarthAnalyzer: TopoCentricSunPositionResult 3. Class Diagram classDiagram SunEarthAnalyzer \"1\" --> \"0..1\" Analyzer: load algorithm SunEarthAnalyzer \"1\" --> \"0..1\" Observatory: set observatory SunEarthAnalyzer --> TopoCentricSunPositionResult: sun position at Analyzer <|-- SPA_Analyzer Analyzer <|-- SG2_Analyzer TopoCentricSunPositionResult --> OBS_TIME_T class SunEarthAnalyzer { +String algorithm +Observatory observatory -Analyzer _impl +has_set_observatory() +sun_position_at(obs_time: OBS_TIME_T) -_load_algorithm() } class Analyzer { -_observatory_set: bool = false +virtual: get_observatory() +virtual: set_observatory(kwargs) +virtual: calc_sun_position_at(year,month,day,hour,minute,second) +has_set_observatory() } <<interface>> Analyzer class SPA_Analyzer { -_observatory: map[string, double] -_spa: spa_data } class SG2_Analyzer { TODO } class Observatory { +longitude: float +latitude: float +elevation: float +timezone: float +delta_ut1: float = 0 +delta_t: float = 0 +pressure: float = 0 +temperature: float = 0 +atmos_refract: float = 0 } class OBS_TIME_T { +year: int +month: int +day: int +hour: int +minute: int +second: int } class TopoCentricSunPositionResult { +zenith: float +azimuth: float +julian_day: float = None +obs_time: OBS_TIME_T = None } Tests by Pytest Currently, only Python code is tested by pytest. You are welcome to incorporate C++ tests. Testing via tox : tox -r -e dev -- -s -v Documentation Preivew Docs is managed by Material for Mkdocs . Preview docs by: tox -r -e docs","title":"Developer's Guide"},{"location":"dev-guide/dev-guide/#developers-guide","text":"","title":"Developer's Guide"},{"location":"dev-guide/dev-guide/#local-development-procedure","text":"Install Anaconda on System Install CMake on System Install C++/C Compiler on System, w.r.t. supported platforms Checkout issue related branch from Github Prepare Python environment, either by pip install -r requirements-dev.txt or pip install tox && tox -e dev Browse and edit source code as your wish, VSCode recommened as the IDE Broadcast your work using towncrier by: towncrier create {source}.{type} --edit where {type} is one of: feature: for new features api: for API changes bug: for bug fixes maint: for maintenance and ci related dev: for breakthrough changes/milestone docs: for documentation changes author: for contributor names and where the {source} part of the filename is: 42 when the change is described in issue 42 PR42 when the change has been implemented in pull request 42, and there is no associated issue Cabcdef when the change has been implemented in changeset abcdef, and there is no associated issue or pull request. username for contributors (author extention). It should be the username part of their commits\u2019 email address.","title":"Local Development Procedure"},{"location":"dev-guide/dev-guide/#library-design","text":"","title":"Library Design"},{"location":"dev-guide/dev-guide/#1-flowchart","text":"flowchart LR i1((Observatory)) i2((OBS_TIME_T)) a1[SunEarthAnalyzer] a2[interface of<br>SPA_Analyzer] b1[SPA_Analyzer] b2[(C implementation of<br>SPA algorithm)] i1---a1 i2---a1 Python<===>|pybind11|CPP subgraph Python a1-->|set_observatory|a2 a1-->|sun_position_at|a2 end subgraph CPP direction TB b1-->|calculate_sun_position_at|b2 end","title":"1. Flowchart"},{"location":"dev-guide/dev-guide/#2-sequence-diagram","text":"sequenceDiagram participant SunEarthAnalyzer participant SPA_Analyzer participant SPA SunEarthAnalyzer ->>+ SPA_Analyzer: load algorithm SPA_Analyzer -->>- SunEarthAnalyzer: calculator SunEarthAnalyzer ->> SPA_Analyzer: set observatory SunEarthAnalyzer ->>+ SPA_Analyzer: sun position at ? % break when observatory not set % SPA_Analyzer -->> SunEarthAnalyzer: RuntimeError % end SPA_Analyzer -->>+ SPA: calculate sun position at ? % break when validate_inputs fails % SPA-->SPA_Analyzer: error code % end SPA -->> SPA: spa calcluate SPA -->>- SPA_Analyzer: spa_data SPA_Analyzer -->>- SunEarthAnalyzer: TopoCentricSunPositionResult","title":"2. Sequence Diagram"},{"location":"dev-guide/dev-guide/#3-class-diagram","text":"classDiagram SunEarthAnalyzer \"1\" --> \"0..1\" Analyzer: load algorithm SunEarthAnalyzer \"1\" --> \"0..1\" Observatory: set observatory SunEarthAnalyzer --> TopoCentricSunPositionResult: sun position at Analyzer <|-- SPA_Analyzer Analyzer <|-- SG2_Analyzer TopoCentricSunPositionResult --> OBS_TIME_T class SunEarthAnalyzer { +String algorithm +Observatory observatory -Analyzer _impl +has_set_observatory() +sun_position_at(obs_time: OBS_TIME_T) -_load_algorithm() } class Analyzer { -_observatory_set: bool = false +virtual: get_observatory() +virtual: set_observatory(kwargs) +virtual: calc_sun_position_at(year,month,day,hour,minute,second) +has_set_observatory() } <<interface>> Analyzer class SPA_Analyzer { -_observatory: map[string, double] -_spa: spa_data } class SG2_Analyzer { TODO } class Observatory { +longitude: float +latitude: float +elevation: float +timezone: float +delta_ut1: float = 0 +delta_t: float = 0 +pressure: float = 0 +temperature: float = 0 +atmos_refract: float = 0 } class OBS_TIME_T { +year: int +month: int +day: int +hour: int +minute: int +second: int } class TopoCentricSunPositionResult { +zenith: float +azimuth: float +julian_day: float = None +obs_time: OBS_TIME_T = None }","title":"3. Class Diagram"},{"location":"dev-guide/dev-guide/#tests-by-pytest","text":"Currently, only Python code is tested by pytest. You are welcome to incorporate C++ tests. Testing via tox : tox -r -e dev -- -s -v","title":"Tests by Pytest"},{"location":"dev-guide/dev-guide/#documentation-preivew","text":"Docs is managed by Material for Mkdocs . Preview docs by: tox -r -e docs","title":"Documentation Preivew"},{"location":"reference/SunEarthAnalyzer/","text":"Bases: object Interface class for sun-earth-analysis Parameters: Name Type Description Default algorithm str currently supports 'SPA'; Defaults to 'SPA' 'SPA' Source code in fseg/_analyzer.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 class SunEarthAnalyzer ( object ): \"\"\" Interface class for sun-earth-analysis Args: algorithm (str): currently supports 'SPA'; Defaults to 'SPA' \"\"\" def __init__ ( self , algorithm : str = \"SPA\" ) -> None : self . _algorithm = algorithm self . _obs = Observatory ( 0.0 , 0.0 , 0.0 , 0.0 ) self . _load_algorithm () def _load_algorithm ( self ): if self . _algorithm . upper () == \"SPA\" : self . _impl = SPA_Analyzer () else : raise ValueError ( f \"Unknown algorithm { self . _algorithm } \" ) def set_observatory ( self , ** kwargs ) -> None : obs_keys = vars ( self . _obs ) for k , v in kwargs . items (): if k in obs_keys : setattr ( self . _obs , k , v ) self . _impl . set_observatory ( ** asdict ( self . _obs )) def get_observatory ( self ) -> Observatory : if self . has_set_observatory (): return safely_from_dict ( self . _impl . get_observatory (), Observatory ) else : return self . _obs def has_set_observatory ( self ) -> bool : \"\"\" check whether observatory is set for analyzer Returns: bool: True for set Examples: >>> sea = SunEarthAnalyzer() >>> sea.has_set_observatory() False >>> sea.sun_position_at(2020,5,13,17,15,30) Traceback (most recent call last): ... RuntimeError: Observatory has not set >>> d = {'timezone': -7.0, 'longitude': -105.1786, 'latitude': 39.742476, ... 'elevation': 1830.14, 'foo': 100.0} >>> sea.set_observatory(**d) >>> sea.has_set_observatory() True \"\"\" return self . _impl . has_set_observatory () def sun_position_at ( self , dt : Any = None , DEBUG : bool = False , ** kwargs ) -> Tuple [ OBS_TIME_T , TopoCentricSunPositionResult ]: \"\"\" API for calculating sun position at a time Args: dt (Any, optional): supports str and datetime format of observation time. Defaults to None, when kwargs of (year, month, day, hour, minute, second) must be given. DEBUG (bool, optional): when set, print result in multiline format. Defaults to False. Raises: ValueError: invalid inputs for observation time or failed at validation stage of the implemented algorithm Returns: (dt,sp) (Tuple[OBS_TIME_T, TopoCentricSunPositionResult]): dt (year,month,day,hour,minute,second): parsed observation time sp: topocentric solar position with julian day Examples: >>> sea = SunEarthAnalyzer() >>> sea.set_observatory( ... longitude=-105.1786, latitude=39.742476, elevation=1830.14, ... timezone=-7.0, delta_ut1=0, delta_t=67, ... pressure=820, temperature=11, atmos_refract=0.5667, ... ) >>> dt, sp = sea.sun_position_at(\"2003-10-17 12:30:30\") >>> dt (2003, 10, 17, 12, 30, 30) >>> sp TopoCentricSunPositionResult(zenith=50.11162202402972, ... azimuth=194.34024051019162, julian_day=2452930.312847222) \"\"\" try : if dt is None : _year , _month = int ( kwargs [ \"year\" ]), int ( kwargs [ \"month\" ]) _day , _hour = int ( kwargs [ \"day\" ]), int ( kwargs [ \"hour\" ]) _minute , _second = int ( kwargs [ \"minute\" ]), int ( kwargs [ \"second\" ]) else : if isinstance ( dt , str ): dt = datetime . strptime ( dt , \"%Y-%m- %d %H:%M:%S\" ) if isinstance ( dt , datetime ): _year , _month , _day = dt . year , dt . month , dt . day _hour , _minute , _second = dt . hour , dt . minute , dt . second else : raise TypeError ( f \"Invalid type for dt: { type ( dt ) } \" ) except Exception : raise ValueError ( f \"Invalid argument: dt= { dt } , { kwargs } \" ) sp = self . _sun_position_at ( _year , _month , _day , _hour , _minute , _second ) if DEBUG : obs = self . get_observatory () print ( \"----------INPUT----------\" ) print ( \"Year: %d \" % _year ) print ( \"Month: %d \" % _month ) print ( \"Day: %d \" % _day ) print ( \"Hour: %d \" % _hour ) print ( \"Minute: %d \" % _minute ) print ( \"Second: %d \" % _second ) print ( \"Timezone: %.6f \" % obs . timezone ) print ( \"Longitude: %.6f \" % obs . longitude ) print ( \"Latitude: %.6f \" % obs . latitude ) print ( \"Elevation: %.6f \" % obs . elevation ) print ( \"Pressure: %.6f \" % obs . pressure ) print ( \"Temperature: %.6f \" % obs . temperature ) print ( \"Atmos_Refract: %.6f \" % obs . atmos_refract ) print ( \"Delta T: %.6f \" % obs . delta_t ) print ( \"----------OUTPUT----------\" ) if sp . julian_day : print ( \"Julian Day: %.6f \" % sp . julian_day ) print ( \"Zenith: %.6f degrees\" % sp . zenith ) print ( \"Azimuth: %.6f degrees\" % sp . azimuth ) dt = ( _year , _month , _day , _hour , _minute , _second ) return dt , sp def _sun_position_at ( self , year : int , month : int , day : int , hour : int , minute : int , second : int ) -> TopoCentricSunPositionResult : \"\"\" directly call c++ library, when performance is critical \"\"\" zenith , azimuth , julian_day = self . _impl . calc_sun_position_at ( year , month , day , hour , minute , second ) return TopoCentricSunPositionResult ( zenith , azimuth , julian_day ) def __repr__ ( self ) -> str : return f \"SunEarthAnalyzer(algorithm= { self . _algorithm } )\" has_set_observatory () check whether observatory is set for analyzer Returns: Name Type Description bool bool True for set Examples: >>> sea = SunEarthAnalyzer () >>> sea . has_set_observatory () False >>> sea . sun_position_at ( 2020 , 5 , 13 , 17 , 15 , 30 ) Traceback (most recent call last): ... RuntimeError : Observatory has not set >>> d = { 'timezone' : - 7.0 , 'longitude' : - 105.1786 , 'latitude' : 39.742476 , ... 'elevation' : 1830.14 , 'foo' : 100.0 } >>> sea . set_observatory ( ** d ) >>> sea . has_set_observatory () True Source code in fseg/_analyzer.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def has_set_observatory ( self ) -> bool : \"\"\" check whether observatory is set for analyzer Returns: bool: True for set Examples: >>> sea = SunEarthAnalyzer() >>> sea.has_set_observatory() False >>> sea.sun_position_at(2020,5,13,17,15,30) Traceback (most recent call last): ... RuntimeError: Observatory has not set >>> d = {'timezone': -7.0, 'longitude': -105.1786, 'latitude': 39.742476, ... 'elevation': 1830.14, 'foo': 100.0} >>> sea.set_observatory(**d) >>> sea.has_set_observatory() True \"\"\" return self . _impl . has_set_observatory () sun_position_at ( dt = None , DEBUG = False , ** kwargs ) API for calculating sun position at a time Parameters: Name Type Description Default dt Any supports str and datetime format of observation time. Defaults to None, when kwargs of (year, month, day, hour, minute, second) must be given. None DEBUG bool when set, print result in multiline format. Defaults to False. False Raises: Type Description ValueError invalid inputs for observation time or failed at validation stage of the implemented algorithm Returns: Type Description dt,sp) (Tuple[OBS_TIME_T, TopoCentricSunPositionResult] dt (year,month,day,hour,minute,second): parsed observation time sp: topocentric solar position with julian day Examples: >>> sea = SunEarthAnalyzer () >>> sea . set_observatory ( ... longitude =- 105.1786 , latitude = 39.742476 , elevation = 1830.14 , ... timezone =- 7.0 , delta_ut1 = 0 , delta_t = 67 , ... pressure = 820 , temperature = 11 , atmos_refract = 0.5667 , ... ) >>> dt , sp = sea . sun_position_at ( \"2003-10-17 12:30:30\" ) >>> dt (2003, 10, 17, 12, 30, 30) >>> sp TopoCentricSunPositionResult(zenith=50.11162202402972, ... azimuth = 194.34024051019162 , julian_day = 2452930.312847222 ) Source code in fseg/_analyzer.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def sun_position_at ( self , dt : Any = None , DEBUG : bool = False , ** kwargs ) -> Tuple [ OBS_TIME_T , TopoCentricSunPositionResult ]: \"\"\" API for calculating sun position at a time Args: dt (Any, optional): supports str and datetime format of observation time. Defaults to None, when kwargs of (year, month, day, hour, minute, second) must be given. DEBUG (bool, optional): when set, print result in multiline format. Defaults to False. Raises: ValueError: invalid inputs for observation time or failed at validation stage of the implemented algorithm Returns: (dt,sp) (Tuple[OBS_TIME_T, TopoCentricSunPositionResult]): dt (year,month,day,hour,minute,second): parsed observation time sp: topocentric solar position with julian day Examples: >>> sea = SunEarthAnalyzer() >>> sea.set_observatory( ... longitude=-105.1786, latitude=39.742476, elevation=1830.14, ... timezone=-7.0, delta_ut1=0, delta_t=67, ... pressure=820, temperature=11, atmos_refract=0.5667, ... ) >>> dt, sp = sea.sun_position_at(\"2003-10-17 12:30:30\") >>> dt (2003, 10, 17, 12, 30, 30) >>> sp TopoCentricSunPositionResult(zenith=50.11162202402972, ... azimuth=194.34024051019162, julian_day=2452930.312847222) \"\"\" try : if dt is None : _year , _month = int ( kwargs [ \"year\" ]), int ( kwargs [ \"month\" ]) _day , _hour = int ( kwargs [ \"day\" ]), int ( kwargs [ \"hour\" ]) _minute , _second = int ( kwargs [ \"minute\" ]), int ( kwargs [ \"second\" ]) else : if isinstance ( dt , str ): dt = datetime . strptime ( dt , \"%Y-%m- %d %H:%M:%S\" ) if isinstance ( dt , datetime ): _year , _month , _day = dt . year , dt . month , dt . day _hour , _minute , _second = dt . hour , dt . minute , dt . second else : raise TypeError ( f \"Invalid type for dt: { type ( dt ) } \" ) except Exception : raise ValueError ( f \"Invalid argument: dt= { dt } , { kwargs } \" ) sp = self . _sun_position_at ( _year , _month , _day , _hour , _minute , _second ) if DEBUG : obs = self . get_observatory () print ( \"----------INPUT----------\" ) print ( \"Year: %d \" % _year ) print ( \"Month: %d \" % _month ) print ( \"Day: %d \" % _day ) print ( \"Hour: %d \" % _hour ) print ( \"Minute: %d \" % _minute ) print ( \"Second: %d \" % _second ) print ( \"Timezone: %.6f \" % obs . timezone ) print ( \"Longitude: %.6f \" % obs . longitude ) print ( \"Latitude: %.6f \" % obs . latitude ) print ( \"Elevation: %.6f \" % obs . elevation ) print ( \"Pressure: %.6f \" % obs . pressure ) print ( \"Temperature: %.6f \" % obs . temperature ) print ( \"Atmos_Refract: %.6f \" % obs . atmos_refract ) print ( \"Delta T: %.6f \" % obs . delta_t ) print ( \"----------OUTPUT----------\" ) if sp . julian_day : print ( \"Julian Day: %.6f \" % sp . julian_day ) print ( \"Zenith: %.6f degrees\" % sp . zenith ) print ( \"Azimuth: %.6f degrees\" % sp . azimuth ) dt = ( _year , _month , _day , _hour , _minute , _second ) return dt , sp","title":"SunEarthAnalyzer"},{"location":"reference/SunEarthAnalyzer/#fseg._analyzer.SunEarthAnalyzer.has_set_observatory","text":"check whether observatory is set for analyzer Returns: Name Type Description bool bool True for set Examples: >>> sea = SunEarthAnalyzer () >>> sea . has_set_observatory () False >>> sea . sun_position_at ( 2020 , 5 , 13 , 17 , 15 , 30 ) Traceback (most recent call last): ... RuntimeError : Observatory has not set >>> d = { 'timezone' : - 7.0 , 'longitude' : - 105.1786 , 'latitude' : 39.742476 , ... 'elevation' : 1830.14 , 'foo' : 100.0 } >>> sea . set_observatory ( ** d ) >>> sea . has_set_observatory () True Source code in fseg/_analyzer.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def has_set_observatory ( self ) -> bool : \"\"\" check whether observatory is set for analyzer Returns: bool: True for set Examples: >>> sea = SunEarthAnalyzer() >>> sea.has_set_observatory() False >>> sea.sun_position_at(2020,5,13,17,15,30) Traceback (most recent call last): ... RuntimeError: Observatory has not set >>> d = {'timezone': -7.0, 'longitude': -105.1786, 'latitude': 39.742476, ... 'elevation': 1830.14, 'foo': 100.0} >>> sea.set_observatory(**d) >>> sea.has_set_observatory() True \"\"\" return self . _impl . has_set_observatory ()","title":"has_set_observatory()"},{"location":"reference/SunEarthAnalyzer/#fseg._analyzer.SunEarthAnalyzer.sun_position_at","text":"API for calculating sun position at a time Parameters: Name Type Description Default dt Any supports str and datetime format of observation time. Defaults to None, when kwargs of (year, month, day, hour, minute, second) must be given. None DEBUG bool when set, print result in multiline format. Defaults to False. False Raises: Type Description ValueError invalid inputs for observation time or failed at validation stage of the implemented algorithm Returns: Type Description dt,sp) (Tuple[OBS_TIME_T, TopoCentricSunPositionResult] dt (year,month,day,hour,minute,second): parsed observation time sp: topocentric solar position with julian day Examples: >>> sea = SunEarthAnalyzer () >>> sea . set_observatory ( ... longitude =- 105.1786 , latitude = 39.742476 , elevation = 1830.14 , ... timezone =- 7.0 , delta_ut1 = 0 , delta_t = 67 , ... pressure = 820 , temperature = 11 , atmos_refract = 0.5667 , ... ) >>> dt , sp = sea . sun_position_at ( \"2003-10-17 12:30:30\" ) >>> dt (2003, 10, 17, 12, 30, 30) >>> sp TopoCentricSunPositionResult(zenith=50.11162202402972, ... azimuth = 194.34024051019162 , julian_day = 2452930.312847222 ) Source code in fseg/_analyzer.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def sun_position_at ( self , dt : Any = None , DEBUG : bool = False , ** kwargs ) -> Tuple [ OBS_TIME_T , TopoCentricSunPositionResult ]: \"\"\" API for calculating sun position at a time Args: dt (Any, optional): supports str and datetime format of observation time. Defaults to None, when kwargs of (year, month, day, hour, minute, second) must be given. DEBUG (bool, optional): when set, print result in multiline format. Defaults to False. Raises: ValueError: invalid inputs for observation time or failed at validation stage of the implemented algorithm Returns: (dt,sp) (Tuple[OBS_TIME_T, TopoCentricSunPositionResult]): dt (year,month,day,hour,minute,second): parsed observation time sp: topocentric solar position with julian day Examples: >>> sea = SunEarthAnalyzer() >>> sea.set_observatory( ... longitude=-105.1786, latitude=39.742476, elevation=1830.14, ... timezone=-7.0, delta_ut1=0, delta_t=67, ... pressure=820, temperature=11, atmos_refract=0.5667, ... ) >>> dt, sp = sea.sun_position_at(\"2003-10-17 12:30:30\") >>> dt (2003, 10, 17, 12, 30, 30) >>> sp TopoCentricSunPositionResult(zenith=50.11162202402972, ... azimuth=194.34024051019162, julian_day=2452930.312847222) \"\"\" try : if dt is None : _year , _month = int ( kwargs [ \"year\" ]), int ( kwargs [ \"month\" ]) _day , _hour = int ( kwargs [ \"day\" ]), int ( kwargs [ \"hour\" ]) _minute , _second = int ( kwargs [ \"minute\" ]), int ( kwargs [ \"second\" ]) else : if isinstance ( dt , str ): dt = datetime . strptime ( dt , \"%Y-%m- %d %H:%M:%S\" ) if isinstance ( dt , datetime ): _year , _month , _day = dt . year , dt . month , dt . day _hour , _minute , _second = dt . hour , dt . minute , dt . second else : raise TypeError ( f \"Invalid type for dt: { type ( dt ) } \" ) except Exception : raise ValueError ( f \"Invalid argument: dt= { dt } , { kwargs } \" ) sp = self . _sun_position_at ( _year , _month , _day , _hour , _minute , _second ) if DEBUG : obs = self . get_observatory () print ( \"----------INPUT----------\" ) print ( \"Year: %d \" % _year ) print ( \"Month: %d \" % _month ) print ( \"Day: %d \" % _day ) print ( \"Hour: %d \" % _hour ) print ( \"Minute: %d \" % _minute ) print ( \"Second: %d \" % _second ) print ( \"Timezone: %.6f \" % obs . timezone ) print ( \"Longitude: %.6f \" % obs . longitude ) print ( \"Latitude: %.6f \" % obs . latitude ) print ( \"Elevation: %.6f \" % obs . elevation ) print ( \"Pressure: %.6f \" % obs . pressure ) print ( \"Temperature: %.6f \" % obs . temperature ) print ( \"Atmos_Refract: %.6f \" % obs . atmos_refract ) print ( \"Delta T: %.6f \" % obs . delta_t ) print ( \"----------OUTPUT----------\" ) if sp . julian_day : print ( \"Julian Day: %.6f \" % sp . julian_day ) print ( \"Zenith: %.6f degrees\" % sp . zenith ) print ( \"Azimuth: %.6f degrees\" % sp . azimuth ) dt = ( _year , _month , _day , _hour , _minute , _second ) return dt , sp","title":"sun_position_at()"},{"location":"reference/data/","text":"Source code in fseg/_data.py 5 6 7 8 9 10 11 12 13 14 15 @dataclass class Observatory : longitude : float latitude : float elevation : float timezone : float delta_ut1 : float = 0 delta_t : float = 0 pressure : float = 0 temperature : float = 0 atmos_refract : float = 0 Source code in fseg/_data.py 18 19 20 21 22 @dataclass class TopoCentricSunPositionResult : zenith : float azimuth : float julian_day : Optional [ float ] = None","title":"DataClasses"},{"location":"user-guide/install/","text":"FSEG is implemented as a python package with a pybind11 extension. Currently, the project is at Pre-Alpha stage, and you can install FSEG either from PYPI or from source. Later, installation with Anaconda is more recommended. with PIP pip install FSEG with GIT pre-requirements It is required that cmake and C++ compiler installed beforehand. Anaconda is also needed to manager python envs. For example, on MacOSX with Homebrew : brew install anaconda brew install cmake clone source code by: git clone https://github.com/mikesongming/SE-Geometry.git build and install After changing to the source directory, it is recommended to use PEP517 -compatible build-system to package the wheel: python -m build -w If successful, install the wheel by pip: pip install dist/fseg- ${ ver } - ${ plat_name } _ ${ arch } .whl","title":"Installation"},{"location":"user-guide/install/#with-pip","text":"pip install FSEG","title":"with PIP"},{"location":"user-guide/install/#with-git","text":"pre-requirements It is required that cmake and C++ compiler installed beforehand. Anaconda is also needed to manager python envs. For example, on MacOSX with Homebrew : brew install anaconda brew install cmake clone source code by: git clone https://github.com/mikesongming/SE-Geometry.git build and install After changing to the source directory, it is recommended to use PEP517 -compatible build-system to package the wheel: python -m build -w If successful, install the wheel by pip: pip install dist/fseg- ${ ver } - ${ plat_name } _ ${ arch } .whl","title":"with GIT"},{"location":"user-guide/usage/","text":"First, import the library: import FSEG print ( FSEG . __version__ ) sun position at Instantialize an analyzer bound to an algorithm , which defaults to \"SPA\" : from FSEG import SunEarthAnalyzer sea = SunEarthAnalyzer () sea = SunEarthAnalyzer ( algorithm = \"SPA\" ) Set the observatory using kwargs arguments: d = { 'timezone' : - 7.0 , 'longitude' : - 105.1786 , 'latitude' : 39.742476 , 'elevation' : 1830.14 , 'foo' : 100.0 } sea . set_observatory ( ** d ) Without setting observatory, a runtime error will be raised when calling for calculation: >>> sea . has_set_observatory () False >>> sea . sun_position_at ( 2020 , 5 , 13 , 17 , 15 , 30 ) Traceback ( most recent call last ): ... RuntimeError : Observatory has not set Call the backend algorithm to calculate sun position at the give time : >>> _ , sp = sea . sun_position_at ( \"2003-10-17 12:30:30\" ) >>> sp TopoCentricSunPositionResult ( zenith = 50.11162202402972 , ... azimuth = 194.34024051019162 , julian_day = 2452930.312847222 ) Other type of arguments like List[int] are also supported, see reference for details.","title":"Usage"},{"location":"user-guide/usage/#sun-position-at","text":"Instantialize an analyzer bound to an algorithm , which defaults to \"SPA\" : from FSEG import SunEarthAnalyzer sea = SunEarthAnalyzer () sea = SunEarthAnalyzer ( algorithm = \"SPA\" ) Set the observatory using kwargs arguments: d = { 'timezone' : - 7.0 , 'longitude' : - 105.1786 , 'latitude' : 39.742476 , 'elevation' : 1830.14 , 'foo' : 100.0 } sea . set_observatory ( ** d ) Without setting observatory, a runtime error will be raised when calling for calculation: >>> sea . has_set_observatory () False >>> sea . sun_position_at ( 2020 , 5 , 13 , 17 , 15 , 30 ) Traceback ( most recent call last ): ... RuntimeError : Observatory has not set Call the backend algorithm to calculate sun position at the give time : >>> _ , sp = sea . sun_position_at ( \"2003-10-17 12:30:30\" ) >>> sp TopoCentricSunPositionResult ( zenith = 50.11162202402972 , ... azimuth = 194.34024051019162 , julian_day = 2452930.312847222 ) Other type of arguments like List[int] are also supported, see reference for details.","title":"sun position at"}]}