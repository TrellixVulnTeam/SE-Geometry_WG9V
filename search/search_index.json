{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FSEG - Fast Sun-Earth Geometry A library on sun position and sunlight analysis from the observer's viewpoint, which comsists of a simplistic python frontend and an extensible C++ backend. Get Started Features & Algorithms Topocentric Sun Position: SPA 1 SG2 Supported Platforms MacOSX-10.12-x86_64 Ubuntu-20.04-manylinux_x86_64 Windows-2022-win_amd64 Reda, I.; Andreas, A. (2003). Solar Position Algorithm for Solar Radiation Applications. 55 pp.; NREL Report No. TP-560-34302, Revised January 2008. \u21a9","title":"Home"},{"location":"#fseg-fast-sun-earth-geometry","text":"A library on sun position and sunlight analysis from the observer's viewpoint, which comsists of a simplistic python frontend and an extensible C++ backend. Get Started","title":"FSEG - Fast Sun-Earth Geometry"},{"location":"#features-algorithms","text":"Topocentric Sun Position: SPA 1 SG2","title":"Features &amp; Algorithms"},{"location":"#supported-platforms","text":"MacOSX-10.12-x86_64 Ubuntu-20.04-manylinux_x86_64 Windows-2022-win_amd64 Reda, I.; Andreas, A. (2003). Solar Position Algorithm for Solar Radiation Applications. 55 pp.; NREL Report No. TP-560-34302, Revised January 2008. \u21a9","title":"Supported Platforms"},{"location":"about/contributing/","text":"Contributing to FSEG \u4f17\u4eba\u62fe\u67f4\u706b\u7130\u9ad8 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Contributions are made to this repo via Issues and Pull Requests (PRs). For those unfamiliar, please visit the \"fork-and-pull\" Git workflow for reference. Reading and following these guidelines will help us make the contribution process easy and effective for everyone involved. Code of Conduct This project and everyone participating in it is governed by the FSEG Code of Conduct . By participating, you are expected to uphold this code. Please report unacceptable behavior to gnosoir@hotmail.com . Issues Issues should be used to report problems with the library, request a new feature, or to discuss potential changes before a PR is created. When you create a new Issue, a template will be loaded that will guide you through collecting and providing the information we need to investigate. If you find an Issue that addresses the problem you're having, please add your own reproduction information to the existing issue rather than creating a new one. Adding a reaction can also help be indicating to our maintainers that a particular problem is affecting more than just the reporter. Pull Requests PRs to our libraries are always welcome and can be a quick way to get your fix or improvement slated for the next release. In general, PRs should: Only fix the bug OR add the functionality in question, not both. Add unit or integration tests for fixed or changed functionality (if a test suite already exists). Address a single concern in the least number of changed lines as possible. Include documentation in the repo, whether as part of the official docs, in docstrings. Be accompanied by a complete Pull Request template (loaded automatically when a PR is created). For changes that address core functionality or would require breaking changes (e.g. a major release), it's best to open an Issue to discuss your proposal first. This is not required but can save time creating and reviewing changes. In general, we follow the \"fork-and-pull\" Git workflow Fork the repository to your own Github account Clone the project to your machine Create a branch locally with a succinct but descriptive name Commit changes to the branch Following any formatting and testing guidelines specific to this repo Push changes to your fork Open a PR in our repository and follow the PR template so that we can efficiently review the changes.","title":"Contributing"},{"location":"about/contributing/#contributing-to-fseg","text":"\u4f17\u4eba\u62fe\u67f4\u706b\u7130\u9ad8 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Contributions are made to this repo via Issues and Pull Requests (PRs). For those unfamiliar, please visit the \"fork-and-pull\" Git workflow for reference. Reading and following these guidelines will help us make the contribution process easy and effective for everyone involved.","title":"Contributing to FSEG"},{"location":"about/contributing/#code-of-conduct","text":"This project and everyone participating in it is governed by the FSEG Code of Conduct . By participating, you are expected to uphold this code. Please report unacceptable behavior to gnosoir@hotmail.com .","title":"Code of Conduct"},{"location":"about/contributing/#issues","text":"Issues should be used to report problems with the library, request a new feature, or to discuss potential changes before a PR is created. When you create a new Issue, a template will be loaded that will guide you through collecting and providing the information we need to investigate. If you find an Issue that addresses the problem you're having, please add your own reproduction information to the existing issue rather than creating a new one. Adding a reaction can also help be indicating to our maintainers that a particular problem is affecting more than just the reporter.","title":"Issues"},{"location":"about/contributing/#pull-requests","text":"PRs to our libraries are always welcome and can be a quick way to get your fix or improvement slated for the next release. In general, PRs should: Only fix the bug OR add the functionality in question, not both. Add unit or integration tests for fixed or changed functionality (if a test suite already exists). Address a single concern in the least number of changed lines as possible. Include documentation in the repo, whether as part of the official docs, in docstrings. Be accompanied by a complete Pull Request template (loaded automatically when a PR is created). For changes that address core functionality or would require breaking changes (e.g. a major release), it's best to open an Issue to discuss your proposal first. This is not required but can save time creating and reviewing changes. In general, we follow the \"fork-and-pull\" Git workflow Fork the repository to your own Github account Clone the project to your machine Create a branch locally with a succinct but descriptive name Commit changes to the branch Following any formatting and testing guidelines specific to this repo Push changes to your fork Open a PR in our repository and follow the PR template so that we can efficiently review the changes.","title":"Pull Requests"},{"location":"about/history/","text":"Release Notes v0.8.0 (2022-07-07) API Changes #24 simplify python frontend api by refactoring c++ backend with pybind11-empowered virtual function overriding and methods overloading Documentation Improvements #24 update flow graph in dev-guid.md and docstring in _analyzer.py Maintenance PR#26 Introduce cmake module to fetch library pybind11 and date-tz; Modify setup.py to support c++17 on MacOSX >= 10.12; and Build windows version on Windows-2022 with manually downloaded tzdata v0.7.6 (2022-06-28) Bug Fixes 30e2f2e fix that collect_news changed last head commit Documentation Improvements PR#22 Update Documents: user-guide/install.md dev-guide/ Maintenance PR#22 Use mermaid-js to draw UML graphs v0.7.5 (2022-06-27) Features PR#20 Adopt Tox for local pytest & mkdocs #18 Add towncrier news collection Documentation Improvements PR#23 Supplement change logs from v0.5.0 to v0.7.5 Maintenance PR#23 Add workflow to build changelog and docs, then publish to GH Pages v0.7.4 (2022-06-21) Bug Fixes PR#14 tweak tag in build_sdist and build_wheel by CIBW Maintenance PR#17 directory refactoring v0.7.2.1 (2022-06-21) Bug Fixes - 0b1abcc call reused workflow publish_pypi.yml with inherited secrets Development Milestone PR#12 support Linux on Ubuntu20.04 and MSVC on windows2019 Maintenance - 6812935 GH checkout with ref and full history PR#15 release triggered ci & publish v0.6.0 (2022-06-18) Maintenance PR#6 customize github action workflows for CI v0.5.0 (2022-05-25) Development Milestone #1 #2 #3 A SunEarthAnalyzer API wrapping pybind11 C++ extension and CI/CD facilities SPA sun position algorithm implemented; Pytest empowered tests; pre-commit hooks, including mypy,isort,black,flake docs ready to gh-deploy by mkdocs, with the material theme empowered by @towncrier","title":"History"},{"location":"about/history/#release-notes","text":"","title":"Release Notes"},{"location":"about/history/#v080-2022-07-07","text":"","title":"v0.8.0 (2022-07-07)"},{"location":"about/history/#api-changes","text":"#24 simplify python frontend api by refactoring c++ backend with pybind11-empowered virtual function overriding and methods overloading","title":"API Changes"},{"location":"about/history/#documentation-improvements","text":"#24 update flow graph in dev-guid.md and docstring in _analyzer.py","title":"Documentation Improvements"},{"location":"about/history/#maintenance","text":"PR#26 Introduce cmake module to fetch library pybind11 and date-tz; Modify setup.py to support c++17 on MacOSX >= 10.12; and Build windows version on Windows-2022 with manually downloaded tzdata","title":"Maintenance"},{"location":"about/history/#v076-2022-06-28","text":"","title":"v0.7.6 (2022-06-28)"},{"location":"about/history/#bug-fixes","text":"30e2f2e fix that collect_news changed last head commit","title":"Bug Fixes"},{"location":"about/history/#documentation-improvements_1","text":"PR#22 Update Documents: user-guide/install.md dev-guide/","title":"Documentation Improvements"},{"location":"about/history/#maintenance_1","text":"PR#22 Use mermaid-js to draw UML graphs","title":"Maintenance"},{"location":"about/history/#v075-2022-06-27","text":"","title":"v0.7.5 (2022-06-27)"},{"location":"about/history/#features","text":"PR#20 Adopt Tox for local pytest & mkdocs #18 Add towncrier news collection","title":"Features"},{"location":"about/history/#documentation-improvements_2","text":"PR#23 Supplement change logs from v0.5.0 to v0.7.5","title":"Documentation Improvements"},{"location":"about/history/#maintenance_2","text":"PR#23 Add workflow to build changelog and docs, then publish to GH Pages","title":"Maintenance"},{"location":"about/history/#v074-2022-06-21","text":"","title":"v0.7.4 (2022-06-21)"},{"location":"about/history/#bug-fixes_1","text":"PR#14 tweak tag in build_sdist and build_wheel by CIBW","title":"Bug Fixes"},{"location":"about/history/#maintenance_3","text":"PR#17 directory refactoring","title":"Maintenance"},{"location":"about/history/#v0721-2022-06-21","text":"","title":"v0.7.2.1 (2022-06-21)"},{"location":"about/history/#bug-fixes_2","text":"- 0b1abcc call reused workflow publish_pypi.yml with inherited secrets","title":"Bug Fixes"},{"location":"about/history/#development-milestone","text":"PR#12 support Linux on Ubuntu20.04 and MSVC on windows2019","title":"Development Milestone"},{"location":"about/history/#maintenance_4","text":"- 6812935 GH checkout with ref and full history PR#15 release triggered ci & publish","title":"Maintenance"},{"location":"about/history/#v060-2022-06-18","text":"","title":"v0.6.0 (2022-06-18)"},{"location":"about/history/#maintenance_5","text":"PR#6 customize github action workflows for CI","title":"Maintenance"},{"location":"about/history/#v050-2022-05-25","text":"","title":"v0.5.0 (2022-05-25)"},{"location":"about/history/#development-milestone_1","text":"#1 #2 #3 A SunEarthAnalyzer API wrapping pybind11 C++ extension and CI/CD facilities SPA sun position algorithm implemented; Pytest empowered tests; pre-commit hooks, including mypy,isort,black,flake docs ready to gh-deploy by mkdocs, with the material theme empowered by @towncrier","title":"Development Milestone"},{"location":"about/license/","text":"License FSEG adopts LGPLv2.1 to boost knowledge sharing between both industrial experts and IT developers. \u672c\u9879\u76ee\u7248\u6743\u91c7\u7528 LGPLv2.1 \u5f00\u6e90\u534f\u8bae\u4ee5\u4fc3\u8fdb\u76f8\u5173\u884c\u4e1a\u77e5\u8bc6\u548cIT\u4f18\u5316\u65b9\u6cd5\u7684\u5171\u4eab; \u5bf9\u4e8e\u5546\u4e1a\u516c\u53f8\uff0c\u8fd9\u610f\u5473\u7740\u57fa\u4e8e\u672c\u9879\u76ee\u7684\u5e93\u6587\u4ef6\u53ef\u4ee5\u8fdb\u884c\u4efb\u610f\u5f00\u6e90\u6216\u8005\u95ed\u6e90\u8f6f\u4ef6\u7684\u5f00\u53d1\uff0c\u4f46\u662f\u5bf9\u672c\u9879\u76ee\u7684 \u4efb\u610f\u4fee\u6539 \u9700\u8981\u91c7\u7528\u540c\u6837\u7684\u534f\u8bae\u5f00\u6e90\u3002","title":"License"},{"location":"about/license/#license","text":"FSEG adopts LGPLv2.1 to boost knowledge sharing between both industrial experts and IT developers. \u672c\u9879\u76ee\u7248\u6743\u91c7\u7528 LGPLv2.1 \u5f00\u6e90\u534f\u8bae\u4ee5\u4fc3\u8fdb\u76f8\u5173\u884c\u4e1a\u77e5\u8bc6\u548cIT\u4f18\u5316\u65b9\u6cd5\u7684\u5171\u4eab; \u5bf9\u4e8e\u5546\u4e1a\u516c\u53f8\uff0c\u8fd9\u610f\u5473\u7740\u57fa\u4e8e\u672c\u9879\u76ee\u7684\u5e93\u6587\u4ef6\u53ef\u4ee5\u8fdb\u884c\u4efb\u610f\u5f00\u6e90\u6216\u8005\u95ed\u6e90\u8f6f\u4ef6\u7684\u5f00\u53d1\uff0c\u4f46\u662f\u5bf9\u672c\u9879\u76ee\u7684 \u4efb\u610f\u4fee\u6539 \u9700\u8981\u91c7\u7528\u540c\u6837\u7684\u534f\u8bae\u5f00\u6e90\u3002","title":"License"},{"location":"about/motive/","text":"When tring to build an autonomous site planning model, I was shocked by the backwardness of sunlight analysis technology in the Chinese real estate design industry: all available products are distributed as close-sourced \"plugins\" [\u7528\u8fc7\u7684\u90fd\u77e5\u9053~] in commercial desktop softwares, such as AutoCAD and Rhino Grasshopper . Worse yet, many are slow and not upgraded for years. no python package available makes it impossible to utilize DNN models, which nowadays are usually implemented on either tensorflow or pytorch , and nothing else . The problem of sun position involves not only solar astronomy about space-time transformation between celestial and topocentric coordinates, but also convention in specific industries. It needs great effort for a single person to comprehend related knowledge scattered in various papers and documents. Thus FSEG is initiated as: a container of algorithms and know-how on sun position in different industries an easy-to-use API to relieve users from underlying astronomical and computational complexities","title":"Motivation"},{"location":"dev-guide/dev-guide/","text":"Developer's Guide Local Development Procedure Install Anaconda on System Install CMake on System Install C++/C Compiler on System, w.r.t. supported platforms Checkout issue related branch from Github Prepare Python environment, either by pip install -r requirements-dev.txt or pip install tox && tox -e dev Add pre-commit git hooks python -m pre_commit install Browse and edit source code as your wish, VSCode recommened as the IDE Broadcast your work using towncrier by: towncrier create {source}.{type} --edit where {type} is one of: feature: for new features api: for API changes bug: for bug fixes maint: for maintenance and ci related dev: for breakthrough changes/milestone doc: for documentation changes author: for contributor names and where the {source} part of the filename is: 42 when the change is described in issue 42 PR42 when the change has been implemented in pull request 42, and there is no associated issue Cabcdef when the change has been implemented in changeset abcdef, and there is no associated issue or pull request. username for contributors (author extention). It should be the username part of their commits\u2019 email address. Library Design 1. Flowchart flowchart LR i1((Observatory)) i2((Local Datatime)) c1[SunEarthAnalyzer] a1[py::Algorithm] a2[py::SPACalculator] b1[Algorithm] b2[SPACalculator] d1[(C implementation of<br>SPA algorithm)] i1---c1 i2---c1 Py<===>|pybind11|Cpp subgraph Frontend c1--->Py subgraph Py direction TB a1-->a2 end end subgraph Backend Cpp--->d1 subgraph Cpp direction TB b1-->b2 end end 2. Sequence Diagram sequenceDiagram participant SunEarthAnalyzer participant SPACalculator participant SPA SunEarthAnalyzer ->>+ SPACalculator: load algorithm SPACalculator -->>- SunEarthAnalyzer: calculator SunEarthAnalyzer ->> SPACalculator: set observatory SunEarthAnalyzer ->> SPACalculator: set local datetime SunEarthAnalyzer ->>+ SPACalculator: sun position ? % break when observatory not set % SPACalculator -->> SunEarthAnalyzer: RuntimeError % end SPACalculator -->>+ SPA: calculate sun position at ? % break when validate_inputs fails % SPA-->SPACalculator: error code % end SPA -->> SPA: spa calcluate SPA -->>- SPACalculator: spa_data SPACalculator -->>- SunEarthAnalyzer: TopoCentricSunPositionResult 3. Class Diagram classDiagram SunEarthAnalyzer \"1\" --> \"0..1\" Algorithm: load algorithm SunEarthAnalyzer \"1\" --> \"0..1\" Observatory: set observatory SunEarthAnalyzer --> TopoCentricSunPositionResult: sun position at Algorithm <|-- SPACalculator Algorithm <|-- SG2_Calculator Algorithm <|-- Other_Algorithm class SunEarthAnalyzer { +algorithm: string +observatory: Observatory +registered: dict -_impl: Algorithm +has_set_observatory() +sun_position_at(local_datetime) -_load_algorithm() } class Algorithm { -_observatory_set: bool = false -_local_datetime_set: bool = false -_observatory: map<string, double> -_local_datetime: array<int> + static OBS_FIELDS: vector<string> +has_set_observatory() +get_observatory() +set_observatory(...) +has_set_local_datetime() +get_local_datetime() +set_local_datetime(...) +virtual: name() +virtual: calc_sun_position() } <<interface>> Algorithm class SPACalculator { -_spa: spa_data } class SG2_Calculator { TODO } class Observatory { +longitude: float +latitude: float +elevation: float +timezone: float +delta_ut1: float = 0 +delta_t: float = 0 +pressure: float = 0 +temperature: float = 0 +atmos_refract: float = 0 } class TopoCentricSunPositionResult { +zenith: float +azimuth: float +julian_day: float = None } How to add algorithm Add an sub-class of Algorithm , implementing two methods: name and calc_sun_position Add a pybind11 trampoline class for the new algorithm class for automatic downcasting Bind the algorithm to python in src/cpp/main.cpp py :: class_ < SPACalculator , Algorithm , PySPACaculator > ( m , \"SPACalculator\" ) . def ( py :: init <> ()) . def_property_readonly ( \"name\" , & SPACalculator :: name ) . def ( \"calc_sun_position\" , & SPACalculator :: calc_sun_position ); Register the algorithm in src/python/fseg/impl/__init__.py registered_algorithms = { \"SPA\" : SPACalculator , } Tests by Pytest Currently, only Python code is tested by pytest. You are welcome to incorporate C++ tests. Testing via tox : tox -r -e dev -- -s -v Documentation Preivew Docs is managed by Material for Mkdocs . Preview docs by: tox -r -e docs","title":"Developer's Guide"},{"location":"dev-guide/dev-guide/#developers-guide","text":"","title":"Developer's Guide"},{"location":"dev-guide/dev-guide/#local-development-procedure","text":"Install Anaconda on System Install CMake on System Install C++/C Compiler on System, w.r.t. supported platforms Checkout issue related branch from Github Prepare Python environment, either by pip install -r requirements-dev.txt or pip install tox && tox -e dev Add pre-commit git hooks python -m pre_commit install Browse and edit source code as your wish, VSCode recommened as the IDE Broadcast your work using towncrier by: towncrier create {source}.{type} --edit where {type} is one of: feature: for new features api: for API changes bug: for bug fixes maint: for maintenance and ci related dev: for breakthrough changes/milestone doc: for documentation changes author: for contributor names and where the {source} part of the filename is: 42 when the change is described in issue 42 PR42 when the change has been implemented in pull request 42, and there is no associated issue Cabcdef when the change has been implemented in changeset abcdef, and there is no associated issue or pull request. username for contributors (author extention). It should be the username part of their commits\u2019 email address.","title":"Local Development Procedure"},{"location":"dev-guide/dev-guide/#library-design","text":"","title":"Library Design"},{"location":"dev-guide/dev-guide/#1-flowchart","text":"flowchart LR i1((Observatory)) i2((Local Datatime)) c1[SunEarthAnalyzer] a1[py::Algorithm] a2[py::SPACalculator] b1[Algorithm] b2[SPACalculator] d1[(C implementation of<br>SPA algorithm)] i1---c1 i2---c1 Py<===>|pybind11|Cpp subgraph Frontend c1--->Py subgraph Py direction TB a1-->a2 end end subgraph Backend Cpp--->d1 subgraph Cpp direction TB b1-->b2 end end","title":"1. Flowchart"},{"location":"dev-guide/dev-guide/#2-sequence-diagram","text":"sequenceDiagram participant SunEarthAnalyzer participant SPACalculator participant SPA SunEarthAnalyzer ->>+ SPACalculator: load algorithm SPACalculator -->>- SunEarthAnalyzer: calculator SunEarthAnalyzer ->> SPACalculator: set observatory SunEarthAnalyzer ->> SPACalculator: set local datetime SunEarthAnalyzer ->>+ SPACalculator: sun position ? % break when observatory not set % SPACalculator -->> SunEarthAnalyzer: RuntimeError % end SPACalculator -->>+ SPA: calculate sun position at ? % break when validate_inputs fails % SPA-->SPACalculator: error code % end SPA -->> SPA: spa calcluate SPA -->>- SPACalculator: spa_data SPACalculator -->>- SunEarthAnalyzer: TopoCentricSunPositionResult","title":"2. Sequence Diagram"},{"location":"dev-guide/dev-guide/#3-class-diagram","text":"classDiagram SunEarthAnalyzer \"1\" --> \"0..1\" Algorithm: load algorithm SunEarthAnalyzer \"1\" --> \"0..1\" Observatory: set observatory SunEarthAnalyzer --> TopoCentricSunPositionResult: sun position at Algorithm <|-- SPACalculator Algorithm <|-- SG2_Calculator Algorithm <|-- Other_Algorithm class SunEarthAnalyzer { +algorithm: string +observatory: Observatory +registered: dict -_impl: Algorithm +has_set_observatory() +sun_position_at(local_datetime) -_load_algorithm() } class Algorithm { -_observatory_set: bool = false -_local_datetime_set: bool = false -_observatory: map<string, double> -_local_datetime: array<int> + static OBS_FIELDS: vector<string> +has_set_observatory() +get_observatory() +set_observatory(...) +has_set_local_datetime() +get_local_datetime() +set_local_datetime(...) +virtual: name() +virtual: calc_sun_position() } <<interface>> Algorithm class SPACalculator { -_spa: spa_data } class SG2_Calculator { TODO } class Observatory { +longitude: float +latitude: float +elevation: float +timezone: float +delta_ut1: float = 0 +delta_t: float = 0 +pressure: float = 0 +temperature: float = 0 +atmos_refract: float = 0 } class TopoCentricSunPositionResult { +zenith: float +azimuth: float +julian_day: float = None }","title":"3. Class Diagram"},{"location":"dev-guide/dev-guide/#how-to-add-algorithm","text":"Add an sub-class of Algorithm , implementing two methods: name and calc_sun_position Add a pybind11 trampoline class for the new algorithm class for automatic downcasting Bind the algorithm to python in src/cpp/main.cpp py :: class_ < SPACalculator , Algorithm , PySPACaculator > ( m , \"SPACalculator\" ) . def ( py :: init <> ()) . def_property_readonly ( \"name\" , & SPACalculator :: name ) . def ( \"calc_sun_position\" , & SPACalculator :: calc_sun_position ); Register the algorithm in src/python/fseg/impl/__init__.py registered_algorithms = { \"SPA\" : SPACalculator , }","title":"How to add algorithm"},{"location":"dev-guide/dev-guide/#tests-by-pytest","text":"Currently, only Python code is tested by pytest. You are welcome to incorporate C++ tests. Testing via tox : tox -r -e dev -- -s -v","title":"Tests by Pytest"},{"location":"dev-guide/dev-guide/#documentation-preivew","text":"Docs is managed by Material for Mkdocs . Preview docs by: tox -r -e docs","title":"Documentation Preivew"},{"location":"reference/SunEarthAnalyzer/","text":"Interface class for sun-earth-analysis Attributes: Name Type Description registered map of algorithm name to its implementation class algorithm name of algorithm observatory relevant geological information of location Source code in fseg/_analyzer.py class SunEarthAnalyzer ( object ): \"\"\" Interface class for sun-earth-analysis Attributes: registered: map of algorithm name to its implementation class algorithm: name of algorithm observatory: relevant geological information of location \"\"\" def __init__ ( self ) -> None : self . registered = registered_algorithms @property def algorithm ( self ) -> Optional [ str ]: \"\"\" unique name of algorithm Returns: Optional[str]: None if no algorithm loaded \"\"\" if hasattr ( self , \"_impl\" ): return self . _impl . name else : return None @algorithm . setter def algorithm ( self , algorithm : str ): if hasattr ( self , \"_impl\" ): del self . _impl self . _load_algorithm ( algorithm ) def _load_algorithm ( self , _algorithm : str ): algo_cls = self . registered . get ( _algorithm ) if algo_cls : self . _impl = algo_cls () else : raise ValueError ( f \"Unknown algorithm: { _algorithm } \" ) @property def observatory ( self ) -> Optional [ Observatory ]: \"\"\" wrap c++ map<string, double> with dataclass Observatory Returns: Optional[Observatory]: None if observatory not set \"\"\" if self . has_set_observatory (): return Observatory ( ** self . _impl . get_observatory ()) else : return None @observatory . setter def observatory ( self , value : Observatory_INPUT ): if hasattr ( self , \"_impl\" ): if isinstance ( value , dict ): value = Observatory ( ** value ) self . _impl . set_observatory ( asdict ( value )) def has_set_observatory ( self ) -> bool : \"\"\" check whether observatory is set for analyzer Returns: bool: True for set Examples: >>> sea = SunEarthAnalyzer() >>> sea.algorithm = \"SPA\" >>> sea.has_set_observatory() False >>> sea.sun_position_at([2020, 5, 13, 17, 15, 30]) Traceback (most recent call last): ... RuntimeError: Observatory is unset >>> d = {'timezone': -7.0, 'longitude': -105.1786, 'latitude': 39.742476, ... 'elevation': 1830.14} >>> sea.observatory = d >>> sea.has_set_observatory() True >>> sea.observatory Observatory(longitude=-105.1786, latitude=39.742476, elevation=1830.14, timezone=-7.0, delta_ut1=0.0, delta_t=0.0, pressure=0.0, temperature=0.0, atmos_refract=0.0) \"\"\" return hasattr ( self , \"_impl\" ) and self . _impl . has_set_observatory () def sun_position_at ( self , dt : DateTime_INPUT ) -> TopoCentricSunPositionResult : \"\"\" API for calculating sun position at a time Args: dt (DateTime_INPUT): supports str, datetime and array format of observation time. Raises: ValueError: invalid inputs for observation time or failed at validation stage of the implemented algorithm Returns: sp (TopoCentricSunPositionResult): topocentric solar position with optional Julian day Examples: >>> sea = SunEarthAnalyzer() >>> sea.algorithm = \"SPA\" >>> sea.observatory = Observatory( ... longitude=-105.1786, latitude=39.742476, elevation=1830.14, ... timezone=-7.0, delta_ut1=0, delta_t=67, ... pressure=820, temperature=11, atmos_refract=0.5667, ... ) >>> sp = sea.sun_position_at(\"2003-10-17 12:30:30\") >>> sp TopoCentricSunPositionResult(zenith=50.11162202402972, ... azimuth=194.34024051019162, julian_day=2452930.312847222) >>> sea._impl.get_local_datetime() [2003, 10, 17, 12, 30, 30] \"\"\" self . _impl . set_local_datetime ( dt ) return TopoCentricSunPositionResult ( * self . _impl . calc_sun_position ()) def __repr__ ( self ) -> str : return f \"SunEarthAnalyzer(algorithm= { self . algorithm } )\" @staticmethod def print_sun_position_details ( observatory : Observatory , local_datetime : LocalDateTime , sun_position : TopoCentricSunPositionResult , ): \"\"\" print result in multiline format, for DEBUG Args: observatory (Observatory): _description_ local_datetime (LocalDateTime): _description_ sun_position (TopoCentricSunPositionResult): _description_ \"\"\" print ( \"----------INPUT----------\" ) print ( \"Year: %d \" % local_datetime [ 0 ]) print ( \"Month: %d \" % local_datetime [ 1 ]) print ( \"Day: %d \" % local_datetime [ 2 ]) print ( \"Hour: %d \" % local_datetime [ 3 ]) print ( \"Minute: %d \" % local_datetime [ 4 ]) print ( \"Second: %d \" % local_datetime [ 5 ]) print ( \"Timezone: %.6f \" % observatory . timezone ) print ( \"Longitude: %.6f \" % observatory . longitude ) print ( \"Latitude: %.6f \" % observatory . latitude ) print ( \"Elevation: %.6f \" % observatory . elevation ) print ( \"Pressure: %.6f \" % observatory . pressure ) print ( \"Temperature: %.6f \" % observatory . temperature ) print ( \"Atmos_Refract: %.6f \" % observatory . atmos_refract ) print ( \"Delta T: %.6f \" % observatory . delta_t ) print ( \"----------OUTPUT----------\" ) if sun_position . julian_day : print ( \"Julian Day: %.6f \" % sun_position . julian_day ) print ( \"Zenith: %.6f degrees\" % sun_position . zenith ) print ( \"Azimuth: %.6f degrees\" % sun_position . azimuth ) algorithm : Optional [ str ] property writable unique name of algorithm Returns: Type Description Optional[str] None if no algorithm loaded observatory : Optional [ fseg . _data . Observatory ] property writable wrap c++ map with dataclass Observatory Returns: Type Description Optional[Observatory] None if observatory not set has_set_observatory ( self ) check whether observatory is set for analyzer Returns: Type Description bool True for set Examples: >>> sea = SunEarthAnalyzer () >>> sea . algorithm = \"SPA\" >>> sea . has_set_observatory () False >>> sea . sun_position_at ([ 2020 , 5 , 13 , 17 , 15 , 30 ]) Traceback ( most recent call last ): ... RuntimeError : Observatory is unset >>> d = { 'timezone' : - 7.0 , 'longitude' : - 105.1786 , 'latitude' : 39.742476 , ... 'elevation' : 1830.14 } >>> sea . observatory = d >>> sea . has_set_observatory () True >>> sea . observatory Observatory ( longitude =- 105.1786 , latitude = 39.742476 , elevation = 1830.14 , timezone =- 7.0 , delta_ut1 = 0.0 , delta_t = 0.0 , pressure = 0.0 , temperature = 0.0 , atmos_refract = 0.0 ) Source code in fseg/_analyzer.py def has_set_observatory ( self ) -> bool : \"\"\" check whether observatory is set for analyzer Returns: bool: True for set Examples: >>> sea = SunEarthAnalyzer() >>> sea.algorithm = \"SPA\" >>> sea.has_set_observatory() False >>> sea.sun_position_at([2020, 5, 13, 17, 15, 30]) Traceback (most recent call last): ... RuntimeError: Observatory is unset >>> d = {'timezone': -7.0, 'longitude': -105.1786, 'latitude': 39.742476, ... 'elevation': 1830.14} >>> sea.observatory = d >>> sea.has_set_observatory() True >>> sea.observatory Observatory(longitude=-105.1786, latitude=39.742476, elevation=1830.14, timezone=-7.0, delta_ut1=0.0, delta_t=0.0, pressure=0.0, temperature=0.0, atmos_refract=0.0) \"\"\" return hasattr ( self , \"_impl\" ) and self . _impl . has_set_observatory () print_sun_position_details ( observatory , local_datetime , sun_position ) staticmethod print result in multiline format, for DEBUG Parameters: Name Type Description Default observatory Observatory description required local_datetime LocalDateTime description required sun_position TopoCentricSunPositionResult description required Source code in fseg/_analyzer.py @staticmethod def print_sun_position_details ( observatory : Observatory , local_datetime : LocalDateTime , sun_position : TopoCentricSunPositionResult , ): \"\"\" print result in multiline format, for DEBUG Args: observatory (Observatory): _description_ local_datetime (LocalDateTime): _description_ sun_position (TopoCentricSunPositionResult): _description_ \"\"\" print ( \"----------INPUT----------\" ) print ( \"Year: %d \" % local_datetime [ 0 ]) print ( \"Month: %d \" % local_datetime [ 1 ]) print ( \"Day: %d \" % local_datetime [ 2 ]) print ( \"Hour: %d \" % local_datetime [ 3 ]) print ( \"Minute: %d \" % local_datetime [ 4 ]) print ( \"Second: %d \" % local_datetime [ 5 ]) print ( \"Timezone: %.6f \" % observatory . timezone ) print ( \"Longitude: %.6f \" % observatory . longitude ) print ( \"Latitude: %.6f \" % observatory . latitude ) print ( \"Elevation: %.6f \" % observatory . elevation ) print ( \"Pressure: %.6f \" % observatory . pressure ) print ( \"Temperature: %.6f \" % observatory . temperature ) print ( \"Atmos_Refract: %.6f \" % observatory . atmos_refract ) print ( \"Delta T: %.6f \" % observatory . delta_t ) print ( \"----------OUTPUT----------\" ) if sun_position . julian_day : print ( \"Julian Day: %.6f \" % sun_position . julian_day ) print ( \"Zenith: %.6f degrees\" % sun_position . zenith ) print ( \"Azimuth: %.6f degrees\" % sun_position . azimuth ) sun_position_at ( self , dt ) API for calculating sun position at a time Parameters: Name Type Description Default dt DateTime_INPUT supports str, datetime and array format of observation time. required Exceptions: Type Description ValueError invalid inputs for observation time or failed at validation stage of the implemented algorithm Returns: Type Description sp (TopoCentricSunPositionResult) topocentric solar position with optional Julian day Examples: >>> sea = SunEarthAnalyzer () >>> sea . algorithm = \"SPA\" >>> sea . observatory = Observatory ( ... longitude =- 105.1786 , latitude = 39.742476 , elevation = 1830.14 , ... timezone =- 7.0 , delta_ut1 = 0 , delta_t = 67 , ... pressure = 820 , temperature = 11 , atmos_refract = 0.5667 , ... ) >>> sp = sea . sun_position_at ( \"2003-10-17 12:30:30\" ) >>> sp TopoCentricSunPositionResult ( zenith = 50.11162202402972 , ... azimuth = 194.34024051019162 , julian_day = 2452930.312847222 ) >>> sea . _impl . get_local_datetime () [ 2003 , 10 , 17 , 12 , 30 , 30 ] Source code in fseg/_analyzer.py def sun_position_at ( self , dt : DateTime_INPUT ) -> TopoCentricSunPositionResult : \"\"\" API for calculating sun position at a time Args: dt (DateTime_INPUT): supports str, datetime and array format of observation time. Raises: ValueError: invalid inputs for observation time or failed at validation stage of the implemented algorithm Returns: sp (TopoCentricSunPositionResult): topocentric solar position with optional Julian day Examples: >>> sea = SunEarthAnalyzer() >>> sea.algorithm = \"SPA\" >>> sea.observatory = Observatory( ... longitude=-105.1786, latitude=39.742476, elevation=1830.14, ... timezone=-7.0, delta_ut1=0, delta_t=67, ... pressure=820, temperature=11, atmos_refract=0.5667, ... ) >>> sp = sea.sun_position_at(\"2003-10-17 12:30:30\") >>> sp TopoCentricSunPositionResult(zenith=50.11162202402972, ... azimuth=194.34024051019162, julian_day=2452930.312847222) >>> sea._impl.get_local_datetime() [2003, 10, 17, 12, 30, 30] \"\"\" self . _impl . set_local_datetime ( dt ) return TopoCentricSunPositionResult ( * self . _impl . calc_sun_position ())","title":"SunEarthAnalyzer"},{"location":"reference/SunEarthAnalyzer/#fseg._analyzer.SunEarthAnalyzer.algorithm","text":"unique name of algorithm Returns: Type Description Optional[str] None if no algorithm loaded","title":"algorithm"},{"location":"reference/SunEarthAnalyzer/#fseg._analyzer.SunEarthAnalyzer.observatory","text":"wrap c++ map with dataclass Observatory Returns: Type Description Optional[Observatory] None if observatory not set","title":"observatory"},{"location":"reference/SunEarthAnalyzer/#fseg._analyzer.SunEarthAnalyzer.has_set_observatory","text":"check whether observatory is set for analyzer Returns: Type Description bool True for set Examples: >>> sea = SunEarthAnalyzer () >>> sea . algorithm = \"SPA\" >>> sea . has_set_observatory () False >>> sea . sun_position_at ([ 2020 , 5 , 13 , 17 , 15 , 30 ]) Traceback ( most recent call last ): ... RuntimeError : Observatory is unset >>> d = { 'timezone' : - 7.0 , 'longitude' : - 105.1786 , 'latitude' : 39.742476 , ... 'elevation' : 1830.14 } >>> sea . observatory = d >>> sea . has_set_observatory () True >>> sea . observatory Observatory ( longitude =- 105.1786 , latitude = 39.742476 , elevation = 1830.14 , timezone =- 7.0 , delta_ut1 = 0.0 , delta_t = 0.0 , pressure = 0.0 , temperature = 0.0 , atmos_refract = 0.0 ) Source code in fseg/_analyzer.py def has_set_observatory ( self ) -> bool : \"\"\" check whether observatory is set for analyzer Returns: bool: True for set Examples: >>> sea = SunEarthAnalyzer() >>> sea.algorithm = \"SPA\" >>> sea.has_set_observatory() False >>> sea.sun_position_at([2020, 5, 13, 17, 15, 30]) Traceback (most recent call last): ... RuntimeError: Observatory is unset >>> d = {'timezone': -7.0, 'longitude': -105.1786, 'latitude': 39.742476, ... 'elevation': 1830.14} >>> sea.observatory = d >>> sea.has_set_observatory() True >>> sea.observatory Observatory(longitude=-105.1786, latitude=39.742476, elevation=1830.14, timezone=-7.0, delta_ut1=0.0, delta_t=0.0, pressure=0.0, temperature=0.0, atmos_refract=0.0) \"\"\" return hasattr ( self , \"_impl\" ) and self . _impl . has_set_observatory ()","title":"has_set_observatory()"},{"location":"reference/SunEarthAnalyzer/#fseg._analyzer.SunEarthAnalyzer.print_sun_position_details","text":"print result in multiline format, for DEBUG Parameters: Name Type Description Default observatory Observatory description required local_datetime LocalDateTime description required sun_position TopoCentricSunPositionResult description required Source code in fseg/_analyzer.py @staticmethod def print_sun_position_details ( observatory : Observatory , local_datetime : LocalDateTime , sun_position : TopoCentricSunPositionResult , ): \"\"\" print result in multiline format, for DEBUG Args: observatory (Observatory): _description_ local_datetime (LocalDateTime): _description_ sun_position (TopoCentricSunPositionResult): _description_ \"\"\" print ( \"----------INPUT----------\" ) print ( \"Year: %d \" % local_datetime [ 0 ]) print ( \"Month: %d \" % local_datetime [ 1 ]) print ( \"Day: %d \" % local_datetime [ 2 ]) print ( \"Hour: %d \" % local_datetime [ 3 ]) print ( \"Minute: %d \" % local_datetime [ 4 ]) print ( \"Second: %d \" % local_datetime [ 5 ]) print ( \"Timezone: %.6f \" % observatory . timezone ) print ( \"Longitude: %.6f \" % observatory . longitude ) print ( \"Latitude: %.6f \" % observatory . latitude ) print ( \"Elevation: %.6f \" % observatory . elevation ) print ( \"Pressure: %.6f \" % observatory . pressure ) print ( \"Temperature: %.6f \" % observatory . temperature ) print ( \"Atmos_Refract: %.6f \" % observatory . atmos_refract ) print ( \"Delta T: %.6f \" % observatory . delta_t ) print ( \"----------OUTPUT----------\" ) if sun_position . julian_day : print ( \"Julian Day: %.6f \" % sun_position . julian_day ) print ( \"Zenith: %.6f degrees\" % sun_position . zenith ) print ( \"Azimuth: %.6f degrees\" % sun_position . azimuth )","title":"print_sun_position_details()"},{"location":"reference/SunEarthAnalyzer/#fseg._analyzer.SunEarthAnalyzer.sun_position_at","text":"API for calculating sun position at a time Parameters: Name Type Description Default dt DateTime_INPUT supports str, datetime and array format of observation time. required Exceptions: Type Description ValueError invalid inputs for observation time or failed at validation stage of the implemented algorithm Returns: Type Description sp (TopoCentricSunPositionResult) topocentric solar position with optional Julian day Examples: >>> sea = SunEarthAnalyzer () >>> sea . algorithm = \"SPA\" >>> sea . observatory = Observatory ( ... longitude =- 105.1786 , latitude = 39.742476 , elevation = 1830.14 , ... timezone =- 7.0 , delta_ut1 = 0 , delta_t = 67 , ... pressure = 820 , temperature = 11 , atmos_refract = 0.5667 , ... ) >>> sp = sea . sun_position_at ( \"2003-10-17 12:30:30\" ) >>> sp TopoCentricSunPositionResult ( zenith = 50.11162202402972 , ... azimuth = 194.34024051019162 , julian_day = 2452930.312847222 ) >>> sea . _impl . get_local_datetime () [ 2003 , 10 , 17 , 12 , 30 , 30 ] Source code in fseg/_analyzer.py def sun_position_at ( self , dt : DateTime_INPUT ) -> TopoCentricSunPositionResult : \"\"\" API for calculating sun position at a time Args: dt (DateTime_INPUT): supports str, datetime and array format of observation time. Raises: ValueError: invalid inputs for observation time or failed at validation stage of the implemented algorithm Returns: sp (TopoCentricSunPositionResult): topocentric solar position with optional Julian day Examples: >>> sea = SunEarthAnalyzer() >>> sea.algorithm = \"SPA\" >>> sea.observatory = Observatory( ... longitude=-105.1786, latitude=39.742476, elevation=1830.14, ... timezone=-7.0, delta_ut1=0, delta_t=67, ... pressure=820, temperature=11, atmos_refract=0.5667, ... ) >>> sp = sea.sun_position_at(\"2003-10-17 12:30:30\") >>> sp TopoCentricSunPositionResult(zenith=50.11162202402972, ... azimuth=194.34024051019162, julian_day=2452930.312847222) >>> sea._impl.get_local_datetime() [2003, 10, 17, 12, 30, 30] \"\"\" self . _impl . set_local_datetime ( dt ) return TopoCentricSunPositionResult ( * self . _impl . calc_sun_position ())","title":"sun_position_at()"},{"location":"reference/data/","text":"Observatory(longitude: float, latitude: float, elevation: float, timezone: float, delta_ut1: float = 0, delta_t: float = 0, pressure: float = 0, temperature: float = 0, atmos_refract: float = 0) Source code in fseg/_data.py @dataclass class Observatory : longitude : float latitude : float elevation : float timezone : float delta_ut1 : float = 0 delta_t : float = 0 pressure : float = 0 temperature : float = 0 atmos_refract : float = 0 TopoCentricSunPositionResult(zenith: float, azimuth: float, julian_day: Optional[float] = None) Source code in fseg/_data.py @dataclass class TopoCentricSunPositionResult : zenith : float azimuth : float julian_day : Optional [ float ] = None","title":"DataClasses"},{"location":"user-guide/install/","text":"FSEG is implemented as a python package with a pybind11 extension. Currently, the project is at Pre-Alpha stage, and you can install FSEG either from PYPI or from source. Later, installation with Anaconda is more recommended. with PIP pip install fseg with GIT pre-requirements It is required that cmake and C++ compiler installed beforehand. Anaconda is also needed to manager python envs. For example, on MacOSX with Homebrew : brew install anaconda brew install cmake clone source code by: git clone https://github.com/mikesongming/SE-Geometry.git build and install After changing to the source directory, it is recommended to use PEP517 -compatible build-system to package the wheel: python -m build -w If successful, install the wheel by pip: pip install dist/fseg- ${ ver } - ${ plat_name } _ ${ arch } .whl","title":"Installation"},{"location":"user-guide/install/#with-pip","text":"pip install fseg","title":"with PIP"},{"location":"user-guide/install/#with-git","text":"pre-requirements It is required that cmake and C++ compiler installed beforehand. Anaconda is also needed to manager python envs. For example, on MacOSX with Homebrew : brew install anaconda brew install cmake clone source code by: git clone https://github.com/mikesongming/SE-Geometry.git build and install After changing to the source directory, it is recommended to use PEP517 -compatible build-system to package the wheel: python -m build -w If successful, install the wheel by pip: pip install dist/fseg- ${ ver } - ${ plat_name } _ ${ arch } .whl","title":"with GIT"},{"location":"user-guide/usage/","text":"First, import the library: import fseg print ( fseg . __version__ ) Note Since there is no system time-zone data on Windows , it is necessary to download IANA tzdata for the library date-tz. mkdir $HOME /tzdata cd $HOME /tzdata curl \"https://data.iana.org/time-zones/releases/tzdata2022a.tar.gz\" | tar xvz curl \"https://raw.githubusercontent.com/unicode-org/cldr/main/common/supplemental/windowsZones.xml\" If curl failed with connection refused , manually download the windowsZones.xml file in browser. sun position at Instantialize an analyzer , and bound to an algorithm , for example \"SPA\" : from fseg import SunEarthAnalyzer sea = SunEarthAnalyzer () sea . algorithm = \"SPA\" Set the observatory using kwargs arguments: d = { 'timezone' : - 7.0 , 'longitude' : - 105.1786 , 'latitude' : 39.742476 , 'elevation' : 1830.14 } sea . observatory = d Without setting observatory, a runtime error will be raised when calling for calculation: >>> sea . has_set_observatory () False >>> sea . sun_position_at ([ 2020 , 5 , 13 , 17 , 15 , 30 ]) Traceback ( most recent call last ): ... RuntimeError : Observatory is unset Call the backend algorithm to calculate sun position at the give time : >>> sp = sea . sun_position_at ( \"2003-10-17 12:30:30\" ) >>> sp TopoCentricSunPositionResult ( zenith = 50.11162202402972 , ... azimuth = 194.34024051019162 , julian_day = 2452930.312847222 ) Other type of arguments like List[int] and datetime.datetime are also supported, see reference for details.","title":"Usage"},{"location":"user-guide/usage/#sun-position-at","text":"Instantialize an analyzer , and bound to an algorithm , for example \"SPA\" : from fseg import SunEarthAnalyzer sea = SunEarthAnalyzer () sea . algorithm = \"SPA\" Set the observatory using kwargs arguments: d = { 'timezone' : - 7.0 , 'longitude' : - 105.1786 , 'latitude' : 39.742476 , 'elevation' : 1830.14 } sea . observatory = d Without setting observatory, a runtime error will be raised when calling for calculation: >>> sea . has_set_observatory () False >>> sea . sun_position_at ([ 2020 , 5 , 13 , 17 , 15 , 30 ]) Traceback ( most recent call last ): ... RuntimeError : Observatory is unset Call the backend algorithm to calculate sun position at the give time : >>> sp = sea . sun_position_at ( \"2003-10-17 12:30:30\" ) >>> sp TopoCentricSunPositionResult ( zenith = 50.11162202402972 , ... azimuth = 194.34024051019162 , julian_day = 2452930.312847222 ) Other type of arguments like List[int] and datetime.datetime are also supported, see reference for details.","title":"sun position at"}]}