{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FSEG - Fast Sun-Earth Geometry A library on sun position and sunlight analysis from the observer's viewpoint, which comsists of a simplistic python frontend and an extensible C++ backend. Get Started Features & Algorithms Topocentric Sun Position: SPA 1 SG2 Supported Platforms MacOSX-10.9-x86_64 Reda, I.; Andreas, A. (2003). Solar Position Algorithm for Solar Radiation Applications. 55 pp.; NREL Report No. TP-560-34302, Revised January 2008. \u21a9","title":"Home"},{"location":"#fseg-fast-sun-earth-geometry","text":"A library on sun position and sunlight analysis from the observer's viewpoint, which comsists of a simplistic python frontend and an extensible C++ backend. Get Started","title":"FSEG - Fast Sun-Earth Geometry"},{"location":"#features-algorithms","text":"Topocentric Sun Position: SPA 1 SG2","title":"Features &amp; Algorithms"},{"location":"#supported-platforms","text":"MacOSX-10.9-x86_64 Reda, I.; Andreas, A. (2003). Solar Position Algorithm for Solar Radiation Applications. 55 pp.; NREL Report No. TP-560-34302, Revised January 2008. \u21a9","title":"Supported Platforms"},{"location":"about/contributing/","text":"Contributing to FSEG \u4f17\u4eba\u62fe\u67f4\u706b\u7130\u9ad8 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Contributions are made to this repo via Issues and Pull Requests (PRs). For those unfamiliar, please visit the \"fork-and-pull\" Git workflow for reference. Reading and following these guidelines will help us make the contribution process easy and effective for everyone involved. Code of Conduct This project and everyone participating in it is governed by the FSEG Code of Conduct . By participating, you are expected to uphold this code. Please report unacceptable behavior to gnosoir@hotmail.com . Issues Issues should be used to report problems with the library, request a new feature, or to discuss potential changes before a PR is created. When you create a new Issue, a template will be loaded that will guide you through collecting and providing the information we need to investigate. If you find an Issue that addresses the problem you're having, please add your own reproduction information to the existing issue rather than creating a new one. Adding a reaction can also help be indicating to our maintainers that a particular problem is affecting more than just the reporter. Pull Requests PRs to our libraries are always welcome and can be a quick way to get your fix or improvement slated for the next release. In general, PRs should: Only fix the bug OR add the functionality in question, not both. Add unit or integration tests for fixed or changed functionality (if a test suite already exists). Address a single concern in the least number of changed lines as possible. Include documentation in the repo, whether as part of the official docs, in docstrings. Be accompanied by a complete Pull Request template (loaded automatically when a PR is created). For changes that address core functionality or would require breaking changes (e.g. a major release), it's best to open an Issue to discuss your proposal first. This is not required but can save time creating and reviewing changes. In general, we follow the \"fork-and-pull\" Git workflow Fork the repository to your own Github account Clone the project to your machine Create a branch locally with a succinct but descriptive name Commit changes to the branch Following any formatting and testing guidelines specific to this repo Push changes to your fork Open a PR in our repository and follow the PR template so that we can efficiently review the changes.","title":"Contributing"},{"location":"about/contributing/#contributing-to-fseg","text":"\u4f17\u4eba\u62fe\u67f4\u706b\u7130\u9ad8 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Contributions are made to this repo via Issues and Pull Requests (PRs). For those unfamiliar, please visit the \"fork-and-pull\" Git workflow for reference. Reading and following these guidelines will help us make the contribution process easy and effective for everyone involved.","title":"Contributing to FSEG"},{"location":"about/contributing/#code-of-conduct","text":"This project and everyone participating in it is governed by the FSEG Code of Conduct . By participating, you are expected to uphold this code. Please report unacceptable behavior to gnosoir@hotmail.com .","title":"Code of Conduct"},{"location":"about/contributing/#issues","text":"Issues should be used to report problems with the library, request a new feature, or to discuss potential changes before a PR is created. When you create a new Issue, a template will be loaded that will guide you through collecting and providing the information we need to investigate. If you find an Issue that addresses the problem you're having, please add your own reproduction information to the existing issue rather than creating a new one. Adding a reaction can also help be indicating to our maintainers that a particular problem is affecting more than just the reporter.","title":"Issues"},{"location":"about/contributing/#pull-requests","text":"PRs to our libraries are always welcome and can be a quick way to get your fix or improvement slated for the next release. In general, PRs should: Only fix the bug OR add the functionality in question, not both. Add unit or integration tests for fixed or changed functionality (if a test suite already exists). Address a single concern in the least number of changed lines as possible. Include documentation in the repo, whether as part of the official docs, in docstrings. Be accompanied by a complete Pull Request template (loaded automatically when a PR is created). For changes that address core functionality or would require breaking changes (e.g. a major release), it's best to open an Issue to discuss your proposal first. This is not required but can save time creating and reviewing changes. In general, we follow the \"fork-and-pull\" Git workflow Fork the repository to your own Github account Clone the project to your machine Create a branch locally with a succinct but descriptive name Commit changes to the branch Following any formatting and testing guidelines specific to this repo Push changes to your fork Open a PR in our repository and follow the PR template so that we can efficiently review the changes.","title":"Pull Requests"},{"location":"about/history/","text":"empowered by @Towncrier","title":"History"},{"location":"about/history/#empowered-by-towncrier","text":"","title":"empowered by @Towncrier"},{"location":"about/license/","text":"License FSEG adopts LGPLv2.1 to boost knowledge sharing between both industrial experts and IT developers. \u672c\u9879\u76ee\u7248\u6743\u91c7\u7528 LGPLv2.1 \u5f00\u6e90\u534f\u8bae\u4ee5\u4fc3\u8fdb\u76f8\u5173\u884c\u4e1a\u77e5\u8bc6\u548cIT\u4f18\u5316\u65b9\u6cd5\u7684\u5171\u4eab; \u5bf9\u4e8e\u5546\u4e1a\u516c\u53f8\uff0c\u8fd9\u610f\u5473\u7740\u57fa\u4e8e\u672c\u9879\u76ee\u7684\u5e93\u6587\u4ef6\u53ef\u4ee5\u8fdb\u884c\u4efb\u610f\u5f00\u6e90\u6216\u8005\u95ed\u6e90\u8f6f\u4ef6\u7684\u5f00\u53d1\uff0c\u4f46\u662f\u5bf9\u672c\u9879\u76ee\u7684 \u4efb\u610f\u4fee\u6539 \u9700\u8981\u91c7\u7528\u540c\u6837\u7684\u534f\u8bae\u5f00\u6e90\u3002","title":"License"},{"location":"about/license/#license","text":"FSEG adopts LGPLv2.1 to boost knowledge sharing between both industrial experts and IT developers. \u672c\u9879\u76ee\u7248\u6743\u91c7\u7528 LGPLv2.1 \u5f00\u6e90\u534f\u8bae\u4ee5\u4fc3\u8fdb\u76f8\u5173\u884c\u4e1a\u77e5\u8bc6\u548cIT\u4f18\u5316\u65b9\u6cd5\u7684\u5171\u4eab; \u5bf9\u4e8e\u5546\u4e1a\u516c\u53f8\uff0c\u8fd9\u610f\u5473\u7740\u57fa\u4e8e\u672c\u9879\u76ee\u7684\u5e93\u6587\u4ef6\u53ef\u4ee5\u8fdb\u884c\u4efb\u610f\u5f00\u6e90\u6216\u8005\u95ed\u6e90\u8f6f\u4ef6\u7684\u5f00\u53d1\uff0c\u4f46\u662f\u5bf9\u672c\u9879\u76ee\u7684 \u4efb\u610f\u4fee\u6539 \u9700\u8981\u91c7\u7528\u540c\u6837\u7684\u534f\u8bae\u5f00\u6e90\u3002","title":"License"},{"location":"about/motive/","text":"When tring to build an autonomous site planning model, I was shocked by the backwardness of sunlight analysis technology in the Chinese real estate design industry: all available products are distributed as close-sourced \"plugins\" [\u7528\u8fc7\u7684\u90fd\u77e5\u9053~] in commercial desktop softwares, such as AutoCAD and Rhino Grasshopper . Worse yet, many are slow and not upgraded for years. no python package available makes it impossible to utilize DNN models, which nowadays are usually implemented on either tensorflow or pytorch , and nothing else . The problem of sun position involves not only solar astronomy about space-time transformation between celestial and topocentric coordinates, but also convention in specific industries. It needs great effort for a single person to comprehend related knowledge scattered in various papers and documents. Thus FSEG is initiated as: a container of algorithms and know-how on sun position in different industries an easy-to-use API to relieve users from underlying astronomical and computational complexities","title":"Motivation"},{"location":"dev-guide/dev-guide/","text":"Developer's Guide Getting Started prepare the environment on Mac Pre-commit checks Tests Write Documents Deploy to Local PyPi ToDo","title":"Developer's Guide"},{"location":"dev-guide/dev-guide/#developers-guide","text":"","title":"Developer's Guide"},{"location":"dev-guide/dev-guide/#getting-started","text":"prepare the environment on Mac","title":"Getting Started"},{"location":"dev-guide/dev-guide/#pre-commit-checks","text":"","title":"Pre-commit checks"},{"location":"dev-guide/dev-guide/#tests","text":"","title":"Tests"},{"location":"dev-guide/dev-guide/#write-documents","text":"","title":"Write Documents"},{"location":"dev-guide/dev-guide/#deploy-to-local-pypi","text":"","title":"Deploy to Local PyPi"},{"location":"dev-guide/dev-guide/#todo","text":"","title":"ToDo"},{"location":"reference/SunEarthAnalyzer/","text":"SunEarthAnalyzer Interface class for sun-earth-analysis Parameters: Name Type Description Default algorithm str currently supports 'SPA'; Defaults to 'SPA' 'SPA' Source code in fseg/_analyzer.py class SunEarthAnalyzer ( object ): \"\"\" Interface class for sun-earth-analysis Args: algorithm (str): currently supports 'SPA'; Defaults to 'SPA' \"\"\" def __init__ ( self , algorithm : str = \"SPA\" ) -> None : self . _algorithm = algorithm self . _obs = Observatory ( 0.0 , 0.0 , 0.0 , 0.0 ) self . _load_algorithm () def _load_algorithm ( self ): if self . _algorithm . upper () == \"SPA\" : self . _impl = SPA_Analyzer () else : raise ValueError ( f \"Unknown algorithm { self . _algorithm } \" ) def set_observatory ( self , ** kwargs ) -> None : obs_keys = vars ( self . _obs ) for k , v in kwargs . items (): if k in obs_keys : setattr ( self . _obs , k , v ) self . _impl . set_observatory ( ** asdict ( self . _obs )) def get_observatory ( self ) -> Observatory : if self . has_set_observatory (): return safely_from_dict ( self . _impl . get_observatory (), Observatory ) else : return self . _obs def has_set_observatory ( self ) -> bool : \"\"\" check whether observatory is set for analyzer Returns: bool: True for set Examples: >>> sea = SunEarthAnalyzer() >>> sea.has_set_observatory() False >>> sea.sun_position_at(2020,5,13,17,15,30) Traceback (most recent call last): ... RuntimeError: Observatory has not set >>> d = {'timezone': -7.0, 'longitude': -105.1786, 'latitude': 39.742476, ... 'elevation': 1830.14, 'foo': 100.0} >>> sea.set_observatory(**d) >>> sea.has_set_observatory() True \"\"\" return self . _impl . has_set_observatory () def sun_position_at ( self , dt : Any = None , DEBUG : bool = False , ** kwargs ) -> Tuple [ OBS_TIME_T , TopoCentricSunPositionResult ]: \"\"\" API for calculating sun position at a time Args: dt (Any, optional): supports str and datetime format of observation time. Defaults to None, when kwargs of (year, month, day, hour, minute, second) must be given. DEBUG (bool, optional): when set, print result in multiline format. Defaults to False. Raises: ValueError: invalid inputs for observation time or failed at validation stage of the implemented algorithm Returns: (dt,sp) (Tuple[OBS_TIME_T, TopoCentricSunPositionResult]): dt (year,month,day,hour,minute,second): parsed observation time sp: topocentric solar position with julian day Examples: >>> sea = SunEarthAnalyzer() >>> sea.set_observatory( ... longitude=-105.1786, latitude=39.742476, elevation=1830.14, ... timezone=-7.0, delta_ut1=0, delta_t=67, ... pressure=820, temperature=11, atmos_refract=0.5667, ... ) >>> dt, sp = sea.sun_position_at(\"2003-10-17 12:30:30\") >>> dt (2003, 10, 17, 12, 30, 30) >>> sp TopoCentricSunPositionResult(zenith=50.11162202402972, ... azimuth=194.34024051019162, julian_day=2452930.312847222) \"\"\" try : if dt is None : _year , _month = int ( kwargs [ \"year\" ]), int ( kwargs [ \"month\" ]) _day , _hour = int ( kwargs [ \"day\" ]), int ( kwargs [ \"hour\" ]) _minute , _second = int ( kwargs [ \"minute\" ]), int ( kwargs [ \"second\" ]) else : if isinstance ( dt , str ): dt = datetime . strptime ( dt , \"%Y-%m- %d %H:%M:%S\" ) if isinstance ( dt , datetime ): _year , _month , _day = dt . year , dt . month , dt . day _hour , _minute , _second = dt . hour , dt . minute , dt . second else : raise TypeError ( f \"Invalid type for dt: { type ( dt ) } \" ) except Exception : raise ValueError ( f \"Invalid argument: dt= { dt } , { kwargs } \" ) sp = self . _sun_position_at ( _year , _month , _day , _hour , _minute , _second ) if DEBUG : obs = self . get_observatory () print ( \"----------INPUT----------\" ) print ( \"Year: %d \" % _year ) print ( \"Month: %d \" % _month ) print ( \"Day: %d \" % _day ) print ( \"Hour: %d \" % _hour ) print ( \"Minute: %d \" % _minute ) print ( \"Second: %d \" % _second ) print ( \"Timezone: %.6f \" % obs . timezone ) print ( \"Longitude: %.6f \" % obs . longitude ) print ( \"Latitude: %.6f \" % obs . latitude ) print ( \"Elevation: %.6f \" % obs . elevation ) print ( \"Pressure: %.6f \" % obs . pressure ) print ( \"Temperature: %.6f \" % obs . temperature ) print ( \"Atmos_Refract: %.6f \" % obs . atmos_refract ) print ( \"Delta T: %.6f \" % obs . delta_t ) print ( \"----------OUTPUT----------\" ) if sp . julian_day : print ( \"Julian Day: %.6f \" % sp . julian_day ) print ( \"Zenith: %.6f degrees\" % sp . zenith ) print ( \"Azimuth: %.6f degrees\" % sp . azimuth ) dt = ( _year , _month , _day , _hour , _minute , _second ) return dt , sp def _sun_position_at ( self , year : int , month : int , day : int , hour : int , minute : int , second : int ) -> TopoCentricSunPositionResult : \"\"\" directly call c++ library, when performance is critical \"\"\" zenith , azimuth , julian_day = self . _impl . calc_sun_position_at ( year , month , day , hour , minute , second ) return TopoCentricSunPositionResult ( zenith , azimuth , julian_day ) def __repr__ ( self ) -> str : return f \"SunEarthAnalyzer(algorithm= { self . _algorithm } )\" has_set_observatory ( self ) check whether observatory is set for analyzer Returns: Type Description bool True for set Examples: >>> sea = SunEarthAnalyzer () >>> sea . has_set_observatory () False >>> sea . sun_position_at ( 2020 , 5 , 13 , 17 , 15 , 30 ) Traceback ( most recent call last ): ... RuntimeError : Observatory has not set >>> d = { 'timezone' : - 7.0 , 'longitude' : - 105.1786 , 'latitude' : 39.742476 , ... 'elevation' : 1830.14 , 'foo' : 100.0 } >>> sea . set_observatory ( ** d ) >>> sea . has_set_observatory () True Source code in fseg/_analyzer.py def has_set_observatory ( self ) -> bool : \"\"\" check whether observatory is set for analyzer Returns: bool: True for set Examples: >>> sea = SunEarthAnalyzer() >>> sea.has_set_observatory() False >>> sea.sun_position_at(2020,5,13,17,15,30) Traceback (most recent call last): ... RuntimeError: Observatory has not set >>> d = {'timezone': -7.0, 'longitude': -105.1786, 'latitude': 39.742476, ... 'elevation': 1830.14, 'foo': 100.0} >>> sea.set_observatory(**d) >>> sea.has_set_observatory() True \"\"\" return self . _impl . has_set_observatory () sun_position_at ( self , dt = None , DEBUG = False , ** kwargs ) API for calculating sun position at a time Parameters: Name Type Description Default dt Any supports str and datetime format of observation time. Defaults to None, when kwargs of (year, month, day, hour, minute, second) must be given. None DEBUG bool when set, print result in multiline format. Defaults to False. False Exceptions: Type Description ValueError invalid inputs for observation time or failed at validation stage of the implemented algorithm Returns: Type Description (dt,sp) (Tuple[OBS_TIME_T, TopoCentricSunPositionResult]) dt (year,month,day,hour,minute,second): parsed observation time sp: topocentric solar position with julian day Examples: >>> sea = SunEarthAnalyzer () >>> sea . set_observatory ( ... longitude =- 105.1786 , latitude = 39.742476 , elevation = 1830.14 , ... timezone =- 7.0 , delta_ut1 = 0 , delta_t = 67 , ... pressure = 820 , temperature = 11 , atmos_refract = 0.5667 , ... ) >>> dt , sp = sea . sun_position_at ( \"2003-10-17 12:30:30\" ) >>> dt ( 2003 , 10 , 17 , 12 , 30 , 30 ) >>> sp TopoCentricSunPositionResult ( zenith = 50.11162202402972 , ... azimuth = 194.34024051019162 , julian_day = 2452930.312847222 ) Source code in fseg/_analyzer.py def sun_position_at ( self , dt : Any = None , DEBUG : bool = False , ** kwargs ) -> Tuple [ OBS_TIME_T , TopoCentricSunPositionResult ]: \"\"\" API for calculating sun position at a time Args: dt (Any, optional): supports str and datetime format of observation time. Defaults to None, when kwargs of (year, month, day, hour, minute, second) must be given. DEBUG (bool, optional): when set, print result in multiline format. Defaults to False. Raises: ValueError: invalid inputs for observation time or failed at validation stage of the implemented algorithm Returns: (dt,sp) (Tuple[OBS_TIME_T, TopoCentricSunPositionResult]): dt (year,month,day,hour,minute,second): parsed observation time sp: topocentric solar position with julian day Examples: >>> sea = SunEarthAnalyzer() >>> sea.set_observatory( ... longitude=-105.1786, latitude=39.742476, elevation=1830.14, ... timezone=-7.0, delta_ut1=0, delta_t=67, ... pressure=820, temperature=11, atmos_refract=0.5667, ... ) >>> dt, sp = sea.sun_position_at(\"2003-10-17 12:30:30\") >>> dt (2003, 10, 17, 12, 30, 30) >>> sp TopoCentricSunPositionResult(zenith=50.11162202402972, ... azimuth=194.34024051019162, julian_day=2452930.312847222) \"\"\" try : if dt is None : _year , _month = int ( kwargs [ \"year\" ]), int ( kwargs [ \"month\" ]) _day , _hour = int ( kwargs [ \"day\" ]), int ( kwargs [ \"hour\" ]) _minute , _second = int ( kwargs [ \"minute\" ]), int ( kwargs [ \"second\" ]) else : if isinstance ( dt , str ): dt = datetime . strptime ( dt , \"%Y-%m- %d %H:%M:%S\" ) if isinstance ( dt , datetime ): _year , _month , _day = dt . year , dt . month , dt . day _hour , _minute , _second = dt . hour , dt . minute , dt . second else : raise TypeError ( f \"Invalid type for dt: { type ( dt ) } \" ) except Exception : raise ValueError ( f \"Invalid argument: dt= { dt } , { kwargs } \" ) sp = self . _sun_position_at ( _year , _month , _day , _hour , _minute , _second ) if DEBUG : obs = self . get_observatory () print ( \"----------INPUT----------\" ) print ( \"Year: %d \" % _year ) print ( \"Month: %d \" % _month ) print ( \"Day: %d \" % _day ) print ( \"Hour: %d \" % _hour ) print ( \"Minute: %d \" % _minute ) print ( \"Second: %d \" % _second ) print ( \"Timezone: %.6f \" % obs . timezone ) print ( \"Longitude: %.6f \" % obs . longitude ) print ( \"Latitude: %.6f \" % obs . latitude ) print ( \"Elevation: %.6f \" % obs . elevation ) print ( \"Pressure: %.6f \" % obs . pressure ) print ( \"Temperature: %.6f \" % obs . temperature ) print ( \"Atmos_Refract: %.6f \" % obs . atmos_refract ) print ( \"Delta T: %.6f \" % obs . delta_t ) print ( \"----------OUTPUT----------\" ) if sp . julian_day : print ( \"Julian Day: %.6f \" % sp . julian_day ) print ( \"Zenith: %.6f degrees\" % sp . zenith ) print ( \"Azimuth: %.6f degrees\" % sp . azimuth ) dt = ( _year , _month , _day , _hour , _minute , _second ) return dt , sp","title":"SunEarthAnalyzer"},{"location":"reference/SunEarthAnalyzer/#sunearthanalyzer","text":"Interface class for sun-earth-analysis Parameters: Name Type Description Default algorithm str currently supports 'SPA'; Defaults to 'SPA' 'SPA' Source code in fseg/_analyzer.py class SunEarthAnalyzer ( object ): \"\"\" Interface class for sun-earth-analysis Args: algorithm (str): currently supports 'SPA'; Defaults to 'SPA' \"\"\" def __init__ ( self , algorithm : str = \"SPA\" ) -> None : self . _algorithm = algorithm self . _obs = Observatory ( 0.0 , 0.0 , 0.0 , 0.0 ) self . _load_algorithm () def _load_algorithm ( self ): if self . _algorithm . upper () == \"SPA\" : self . _impl = SPA_Analyzer () else : raise ValueError ( f \"Unknown algorithm { self . _algorithm } \" ) def set_observatory ( self , ** kwargs ) -> None : obs_keys = vars ( self . _obs ) for k , v in kwargs . items (): if k in obs_keys : setattr ( self . _obs , k , v ) self . _impl . set_observatory ( ** asdict ( self . _obs )) def get_observatory ( self ) -> Observatory : if self . has_set_observatory (): return safely_from_dict ( self . _impl . get_observatory (), Observatory ) else : return self . _obs def has_set_observatory ( self ) -> bool : \"\"\" check whether observatory is set for analyzer Returns: bool: True for set Examples: >>> sea = SunEarthAnalyzer() >>> sea.has_set_observatory() False >>> sea.sun_position_at(2020,5,13,17,15,30) Traceback (most recent call last): ... RuntimeError: Observatory has not set >>> d = {'timezone': -7.0, 'longitude': -105.1786, 'latitude': 39.742476, ... 'elevation': 1830.14, 'foo': 100.0} >>> sea.set_observatory(**d) >>> sea.has_set_observatory() True \"\"\" return self . _impl . has_set_observatory () def sun_position_at ( self , dt : Any = None , DEBUG : bool = False , ** kwargs ) -> Tuple [ OBS_TIME_T , TopoCentricSunPositionResult ]: \"\"\" API for calculating sun position at a time Args: dt (Any, optional): supports str and datetime format of observation time. Defaults to None, when kwargs of (year, month, day, hour, minute, second) must be given. DEBUG (bool, optional): when set, print result in multiline format. Defaults to False. Raises: ValueError: invalid inputs for observation time or failed at validation stage of the implemented algorithm Returns: (dt,sp) (Tuple[OBS_TIME_T, TopoCentricSunPositionResult]): dt (year,month,day,hour,minute,second): parsed observation time sp: topocentric solar position with julian day Examples: >>> sea = SunEarthAnalyzer() >>> sea.set_observatory( ... longitude=-105.1786, latitude=39.742476, elevation=1830.14, ... timezone=-7.0, delta_ut1=0, delta_t=67, ... pressure=820, temperature=11, atmos_refract=0.5667, ... ) >>> dt, sp = sea.sun_position_at(\"2003-10-17 12:30:30\") >>> dt (2003, 10, 17, 12, 30, 30) >>> sp TopoCentricSunPositionResult(zenith=50.11162202402972, ... azimuth=194.34024051019162, julian_day=2452930.312847222) \"\"\" try : if dt is None : _year , _month = int ( kwargs [ \"year\" ]), int ( kwargs [ \"month\" ]) _day , _hour = int ( kwargs [ \"day\" ]), int ( kwargs [ \"hour\" ]) _minute , _second = int ( kwargs [ \"minute\" ]), int ( kwargs [ \"second\" ]) else : if isinstance ( dt , str ): dt = datetime . strptime ( dt , \"%Y-%m- %d %H:%M:%S\" ) if isinstance ( dt , datetime ): _year , _month , _day = dt . year , dt . month , dt . day _hour , _minute , _second = dt . hour , dt . minute , dt . second else : raise TypeError ( f \"Invalid type for dt: { type ( dt ) } \" ) except Exception : raise ValueError ( f \"Invalid argument: dt= { dt } , { kwargs } \" ) sp = self . _sun_position_at ( _year , _month , _day , _hour , _minute , _second ) if DEBUG : obs = self . get_observatory () print ( \"----------INPUT----------\" ) print ( \"Year: %d \" % _year ) print ( \"Month: %d \" % _month ) print ( \"Day: %d \" % _day ) print ( \"Hour: %d \" % _hour ) print ( \"Minute: %d \" % _minute ) print ( \"Second: %d \" % _second ) print ( \"Timezone: %.6f \" % obs . timezone ) print ( \"Longitude: %.6f \" % obs . longitude ) print ( \"Latitude: %.6f \" % obs . latitude ) print ( \"Elevation: %.6f \" % obs . elevation ) print ( \"Pressure: %.6f \" % obs . pressure ) print ( \"Temperature: %.6f \" % obs . temperature ) print ( \"Atmos_Refract: %.6f \" % obs . atmos_refract ) print ( \"Delta T: %.6f \" % obs . delta_t ) print ( \"----------OUTPUT----------\" ) if sp . julian_day : print ( \"Julian Day: %.6f \" % sp . julian_day ) print ( \"Zenith: %.6f degrees\" % sp . zenith ) print ( \"Azimuth: %.6f degrees\" % sp . azimuth ) dt = ( _year , _month , _day , _hour , _minute , _second ) return dt , sp def _sun_position_at ( self , year : int , month : int , day : int , hour : int , minute : int , second : int ) -> TopoCentricSunPositionResult : \"\"\" directly call c++ library, when performance is critical \"\"\" zenith , azimuth , julian_day = self . _impl . calc_sun_position_at ( year , month , day , hour , minute , second ) return TopoCentricSunPositionResult ( zenith , azimuth , julian_day ) def __repr__ ( self ) -> str : return f \"SunEarthAnalyzer(algorithm= { self . _algorithm } )\"","title":"SunEarthAnalyzer"},{"location":"reference/SunEarthAnalyzer/#fseg._analyzer.SunEarthAnalyzer.has_set_observatory","text":"check whether observatory is set for analyzer Returns: Type Description bool True for set Examples: >>> sea = SunEarthAnalyzer () >>> sea . has_set_observatory () False >>> sea . sun_position_at ( 2020 , 5 , 13 , 17 , 15 , 30 ) Traceback ( most recent call last ): ... RuntimeError : Observatory has not set >>> d = { 'timezone' : - 7.0 , 'longitude' : - 105.1786 , 'latitude' : 39.742476 , ... 'elevation' : 1830.14 , 'foo' : 100.0 } >>> sea . set_observatory ( ** d ) >>> sea . has_set_observatory () True Source code in fseg/_analyzer.py def has_set_observatory ( self ) -> bool : \"\"\" check whether observatory is set for analyzer Returns: bool: True for set Examples: >>> sea = SunEarthAnalyzer() >>> sea.has_set_observatory() False >>> sea.sun_position_at(2020,5,13,17,15,30) Traceback (most recent call last): ... RuntimeError: Observatory has not set >>> d = {'timezone': -7.0, 'longitude': -105.1786, 'latitude': 39.742476, ... 'elevation': 1830.14, 'foo': 100.0} >>> sea.set_observatory(**d) >>> sea.has_set_observatory() True \"\"\" return self . _impl . has_set_observatory ()","title":"has_set_observatory()"},{"location":"reference/SunEarthAnalyzer/#fseg._analyzer.SunEarthAnalyzer.sun_position_at","text":"API for calculating sun position at a time Parameters: Name Type Description Default dt Any supports str and datetime format of observation time. Defaults to None, when kwargs of (year, month, day, hour, minute, second) must be given. None DEBUG bool when set, print result in multiline format. Defaults to False. False Exceptions: Type Description ValueError invalid inputs for observation time or failed at validation stage of the implemented algorithm Returns: Type Description (dt,sp) (Tuple[OBS_TIME_T, TopoCentricSunPositionResult]) dt (year,month,day,hour,minute,second): parsed observation time sp: topocentric solar position with julian day Examples: >>> sea = SunEarthAnalyzer () >>> sea . set_observatory ( ... longitude =- 105.1786 , latitude = 39.742476 , elevation = 1830.14 , ... timezone =- 7.0 , delta_ut1 = 0 , delta_t = 67 , ... pressure = 820 , temperature = 11 , atmos_refract = 0.5667 , ... ) >>> dt , sp = sea . sun_position_at ( \"2003-10-17 12:30:30\" ) >>> dt ( 2003 , 10 , 17 , 12 , 30 , 30 ) >>> sp TopoCentricSunPositionResult ( zenith = 50.11162202402972 , ... azimuth = 194.34024051019162 , julian_day = 2452930.312847222 ) Source code in fseg/_analyzer.py def sun_position_at ( self , dt : Any = None , DEBUG : bool = False , ** kwargs ) -> Tuple [ OBS_TIME_T , TopoCentricSunPositionResult ]: \"\"\" API for calculating sun position at a time Args: dt (Any, optional): supports str and datetime format of observation time. Defaults to None, when kwargs of (year, month, day, hour, minute, second) must be given. DEBUG (bool, optional): when set, print result in multiline format. Defaults to False. Raises: ValueError: invalid inputs for observation time or failed at validation stage of the implemented algorithm Returns: (dt,sp) (Tuple[OBS_TIME_T, TopoCentricSunPositionResult]): dt (year,month,day,hour,minute,second): parsed observation time sp: topocentric solar position with julian day Examples: >>> sea = SunEarthAnalyzer() >>> sea.set_observatory( ... longitude=-105.1786, latitude=39.742476, elevation=1830.14, ... timezone=-7.0, delta_ut1=0, delta_t=67, ... pressure=820, temperature=11, atmos_refract=0.5667, ... ) >>> dt, sp = sea.sun_position_at(\"2003-10-17 12:30:30\") >>> dt (2003, 10, 17, 12, 30, 30) >>> sp TopoCentricSunPositionResult(zenith=50.11162202402972, ... azimuth=194.34024051019162, julian_day=2452930.312847222) \"\"\" try : if dt is None : _year , _month = int ( kwargs [ \"year\" ]), int ( kwargs [ \"month\" ]) _day , _hour = int ( kwargs [ \"day\" ]), int ( kwargs [ \"hour\" ]) _minute , _second = int ( kwargs [ \"minute\" ]), int ( kwargs [ \"second\" ]) else : if isinstance ( dt , str ): dt = datetime . strptime ( dt , \"%Y-%m- %d %H:%M:%S\" ) if isinstance ( dt , datetime ): _year , _month , _day = dt . year , dt . month , dt . day _hour , _minute , _second = dt . hour , dt . minute , dt . second else : raise TypeError ( f \"Invalid type for dt: { type ( dt ) } \" ) except Exception : raise ValueError ( f \"Invalid argument: dt= { dt } , { kwargs } \" ) sp = self . _sun_position_at ( _year , _month , _day , _hour , _minute , _second ) if DEBUG : obs = self . get_observatory () print ( \"----------INPUT----------\" ) print ( \"Year: %d \" % _year ) print ( \"Month: %d \" % _month ) print ( \"Day: %d \" % _day ) print ( \"Hour: %d \" % _hour ) print ( \"Minute: %d \" % _minute ) print ( \"Second: %d \" % _second ) print ( \"Timezone: %.6f \" % obs . timezone ) print ( \"Longitude: %.6f \" % obs . longitude ) print ( \"Latitude: %.6f \" % obs . latitude ) print ( \"Elevation: %.6f \" % obs . elevation ) print ( \"Pressure: %.6f \" % obs . pressure ) print ( \"Temperature: %.6f \" % obs . temperature ) print ( \"Atmos_Refract: %.6f \" % obs . atmos_refract ) print ( \"Delta T: %.6f \" % obs . delta_t ) print ( \"----------OUTPUT----------\" ) if sp . julian_day : print ( \"Julian Day: %.6f \" % sp . julian_day ) print ( \"Zenith: %.6f degrees\" % sp . zenith ) print ( \"Azimuth: %.6f degrees\" % sp . azimuth ) dt = ( _year , _month , _day , _hour , _minute , _second ) return dt , sp","title":"sun_position_at()"},{"location":"reference/data/","text":"Observatory(longitude: float, latitude: float, elevation: float, timezone: float, delta_ut1: float = 0, delta_t: float = 0, pressure: float = 0, temperature: float = 0, atmos_refract: float = 0) Source code in fseg/_data.py @dataclass class Observatory : longitude : float latitude : float elevation : float timezone : float delta_ut1 : float = 0 delta_t : float = 0 pressure : float = 0 temperature : float = 0 atmos_refract : float = 0 TopoCentricSunPositionResult(zenith: float, azimuth: float, julian_day: Optional[float] = None) Source code in fseg/_data.py @dataclass class TopoCentricSunPositionResult : zenith : float azimuth : float julian_day : Optional [ float ] = None","title":"DataClasses"},{"location":"user-guide/install/","text":"Getting started FSEG is implemented as a python package with a pybind11 extension. Currently, you can only install FSEG from source since the project is at \"Pre-Alpha\" stage. Later, installation with pip is more recommended. Installation pre-requirements Since we need to compile backend extensions before installing the package, it is required that cmake and pybind11 installed beforehand. MacOSX with Homebrew brew install cmake pybind11 with GIT Source code of FSEG can be cloned from Github by: git clone https://github.com/mikesongming/SE-Geometry.git After changing to the source directory, it is recommended to use PEP517 -compatible build-system to package the wheel: python -m build If successful, we can install the wheel by pip: pip install dist/fseg- ${ ver } - ${ plat_name } _ ${ arch } .whl with PIP to be setup Ideally, you can install with: pip install FSEG","title":"Installation"},{"location":"user-guide/install/#getting-started","text":"FSEG is implemented as a python package with a pybind11 extension. Currently, you can only install FSEG from source since the project is at \"Pre-Alpha\" stage. Later, installation with pip is more recommended.","title":"Getting started"},{"location":"user-guide/install/#installation","text":"","title":"Installation"},{"location":"user-guide/install/#pre-requirements","text":"Since we need to compile backend extensions before installing the package, it is required that cmake and pybind11 installed beforehand. MacOSX with Homebrew brew install cmake pybind11","title":"pre-requirements"},{"location":"user-guide/install/#with-git","text":"Source code of FSEG can be cloned from Github by: git clone https://github.com/mikesongming/SE-Geometry.git After changing to the source directory, it is recommended to use PEP517 -compatible build-system to package the wheel: python -m build If successful, we can install the wheel by pip: pip install dist/fseg- ${ ver } - ${ plat_name } _ ${ arch } .whl","title":"with GIT"},{"location":"user-guide/install/#with-pip","text":"Ideally, you can install with: pip install FSEG","title":"with pip"},{"location":"user-guide/usage/","text":"First, import the library: import FSEG print ( FSEG . __version__ ) sun position at Instantialize an analyzer bound to an algorithm , which defaults to \"SPA\" : from FSEG import SunEarthAnalyzer sea = SunEarthAnalyzer () sea = SunEarthAnalyzer ( algorithm = \"SPA\" ) Set the observatory using kwargs arguments: d = { 'timezone' : - 7.0 , 'longitude' : - 105.1786 , 'latitude' : 39.742476 , 'elevation' : 1830.14 , 'foo' : 100.0 } sea . set_observatory ( ** d ) Without setting observatory, a runtime error will be raised when calling for calculation: >>> sea . has_set_observatory () False >>> sea . sun_position_at ( 2020 , 5 , 13 , 17 , 15 , 30 ) Traceback ( most recent call last ): ... RuntimeError : Observatory has not set Call the backend algorithm to calculate sun position at the give time : >>> _ , sp = sea . sun_position_at ( \"2003-10-17 12:30:30\" ) >>> sp TopoCentricSunPositionResult ( zenith = 50.11162202402972 , ... azimuth = 194.34024051019162 , julian_day = 2452930.312847222 ) Other type of arguments like List[int] are also supported, see reference for details.","title":"Usage"},{"location":"user-guide/usage/#sun-position-at","text":"Instantialize an analyzer bound to an algorithm , which defaults to \"SPA\" : from FSEG import SunEarthAnalyzer sea = SunEarthAnalyzer () sea = SunEarthAnalyzer ( algorithm = \"SPA\" ) Set the observatory using kwargs arguments: d = { 'timezone' : - 7.0 , 'longitude' : - 105.1786 , 'latitude' : 39.742476 , 'elevation' : 1830.14 , 'foo' : 100.0 } sea . set_observatory ( ** d ) Without setting observatory, a runtime error will be raised when calling for calculation: >>> sea . has_set_observatory () False >>> sea . sun_position_at ( 2020 , 5 , 13 , 17 , 15 , 30 ) Traceback ( most recent call last ): ... RuntimeError : Observatory has not set Call the backend algorithm to calculate sun position at the give time : >>> _ , sp = sea . sun_position_at ( \"2003-10-17 12:30:30\" ) >>> sp TopoCentricSunPositionResult ( zenith = 50.11162202402972 , ... azimuth = 194.34024051019162 , julian_day = 2452930.312847222 ) Other type of arguments like List[int] are also supported, see reference for details.","title":"sun position at"}]}